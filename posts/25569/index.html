<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux高性能服务器编程 | zzm</title><meta name="description" content="致自己：朝着心中的目标努力奋斗！ Linux系统编程基础Linux开发环境的配置 Linux虚拟机 XShell，Xftp连接软件 VS Code远程代码连接  安装Ubuntu并安装openssh-server、net-tools: 123sudo apt install openssh-serversudo apt install net-toolsifconfig            #"><meta name="keywords" content="linux"><meta name="author" content="zzm"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://aliez22.github.io/posts/25569/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//fastly.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Linux高性能服务器编程"><meta property="og:url" content="https://aliez22.github.io/posts/25569/"><meta property="og:site_name" content="zzm"><meta property="og:description" content="致自己：朝着心中的目标努力奋斗！ Linux系统编程基础Linux开发环境的配置 Linux虚拟机 XShell，Xftp连接软件 VS Code远程代码连接  安装Ubuntu并安装openssh-server、net-tools: 123sudo apt install openssh-serversudo apt install net-toolsifconfig            #"><meta property="og:image" content="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/022.webp"><meta property="article:published_time" content="2021-08-09T09:21:19.000Z"><meta property="article:modified_time" content="2023-02-22T08:50:36.519Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="小新pro14更新windows后的问题-关机后自动重启" href="https://aliez22.github.io/posts/21369/"><link rel="next" title="Github疑难杂症" href="https://aliez22.github.io/posts/64385/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-02-22 16:50:36'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars.githubusercontent.com/u/34917442" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux系统编程基础"><span class="toc-text">Linux系统编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux开发环境的配置"><span class="toc-text">Linux开发环境的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC（GUN-Compiler-Collection）"><span class="toc-text">GCC（GUN Compiler Collection）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态库与动态库"><span class="toc-text">静态库与动态库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile"><span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB调试"><span class="toc-text">GDB调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟地址空间"><span class="toc-text">虚拟地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP协议"><span class="toc-text">TCP&#x2F;IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP协议详解"><span class="toc-text">TCP&#x2F;IP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP协议的工作原理"><span class="toc-text">ARP协议的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP请求-响应报文格式"><span class="toc-text">ARP请求&#x2F;响应报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP高速缓存"><span class="toc-text">ARP高速缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS工作原理"><span class="toc-text">DNS工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS查询和应答报文"><span class="toc-text">DNS查询和应答报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux下访问DNS服务"><span class="toc-text">Linux下访问DNS服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP协议详解"><span class="toc-text">IP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#弄清网络地址，主机地址以及子网掩码的区别"><span class="toc-text">弄清网络地址，主机地址以及子网掩码的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4头部结构"><span class="toc-text">IPv4头部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用tcpdump观察IPv4头部结构"><span class="toc-text">使用tcpdump观察IPv4头部结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP分片"><span class="toc-text">IP分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP路由"><span class="toc-text">IP路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP模块工作流程"><span class="toc-text">IP模块工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由机制"><span class="toc-text">路由机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由表更新"><span class="toc-text">路由表更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP转发"><span class="toc-text">IP转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议详解"><span class="toc-text">TCP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP头部结构"><span class="toc-text">TCP头部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#固定头部结构"><span class="toc-text">固定头部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP头部选项"><span class="toc-text">TCP头部选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用tcpdump观察TCP头部信息"><span class="toc-text">使用tcpdump观察TCP头部信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP连接的建立和关闭"><span class="toc-text">TCP连接的建立和关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#半关闭状态"><span class="toc-text">半关闭状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接超时"><span class="toc-text">连接超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP状态转移"><span class="toc-text">TCP状态转移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP状态转移总图"><span class="toc-text">TCP状态转移总图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TIME-WAIT状态"><span class="toc-text">TIME_WAIT状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复位报文段"><span class="toc-text">复位报文段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问不存在的端口"><span class="toc-text">访问不存在的端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常终止连接"><span class="toc-text">异常终止连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理半打开连接"><span class="toc-text">处理半打开连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的数据流"><span class="toc-text">TCP的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP交互数据流"><span class="toc-text">TCP交互数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP成块数据流"><span class="toc-text">TCP成块数据流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带外数据"><span class="toc-text">带外数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP超时重传"><span class="toc-text">TCP超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP拥塞控制"><span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#慢启动和拥塞避免"><span class="toc-text">慢启动和拥塞避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速重传和快速恢复"><span class="toc-text">快速重传和快速恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP通信案例：访问Internet上的Web服务器"><span class="toc-text">TCP&#x2F;IP通信案例：访问Internet上的Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理服务器"><span class="toc-text">代理服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地名称查询"><span class="toc-text">本地名称查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深入解析高性能服务器编程"><span class="toc-text">深入解析高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux网络编程基础API"><span class="toc-text">Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket地址API"><span class="toc-text">socket地址API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主机字节序和网络字节序"><span class="toc-text">主机字节序和网络字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通用socket地址"><span class="toc-text">通用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#专用socket地址"><span class="toc-text">专用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP地址转换函数"><span class="toc-text">IP地址转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建socket"><span class="toc-text">创建socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名socket"><span class="toc-text">命名socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听socket"><span class="toc-text">监听socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接受连接"><span class="toc-text">接受连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发起连接"><span class="toc-text">发起连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭连接"><span class="toc-text">关闭连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据读写"><span class="toc-text">数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP数据读写"><span class="toc-text">TCP数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP数据读写"><span class="toc-text">UDP数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通用数据读写函数"><span class="toc-text">通用数据读写函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带外标记"><span class="toc-text">带外标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址信息函数"><span class="toc-text">地址信息函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket选项"><span class="toc-text">socket选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络信息API"><span class="toc-text">网络信息API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gethostbyname和gethostbyaddr"><span class="toc-text">gethostbyname和gethostbyaddr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getservbyname和getservbyport"><span class="toc-text">getservbyname和getservbyport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getaddrinfo"><span class="toc-text">getaddrinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getnameinfo"><span class="toc-text">getnameinfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级I-O函数"><span class="toc-text">高级I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe函数"><span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup函数和dup2函数"><span class="toc-text">dup函数和dup2函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readv函数和writev函数"><span class="toc-text">readv函数和writev函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile函数"><span class="toc-text">sendfile函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap函数和munmap函数"><span class="toc-text">mmap函数和munmap函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice函数"><span class="toc-text">splice函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee函数"><span class="toc-text">tee函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl函数"><span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux服务器程序规范"><span class="toc-text">Linux服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#日志"><span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux系统日志"><span class="toc-text">Linux系统日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syslog函数"><span class="toc-text">syslog函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明（2021-9-23）"><span class="toc-text">声明（2021.9.23）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户信息"><span class="toc-text">用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UID、EUID、GID和EGID"><span class="toc-text">UID、EUID、GID和EGID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间关系"><span class="toc-text">进程间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程组"><span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#会话"><span class="toc-text">会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps命令"><span class="toc-text">ps命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统资源限制"><span class="toc-text">系统资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变工作目录和根目录"><span class="toc-text">改变工作目录和根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器程序后台化"><span class="toc-text">服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高性能服务器程序框架"><span class="toc-text">高性能服务器程序框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ex-问题记录"><span class="toc-text">Ex:问题记录</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/022.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">zzm</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Linux高性能服务器编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-08-09 17:21:19"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-08-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-02-22 16:50:36"><i class="fas fa-history fa-fw"></i> 更新于 2023-02-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>致自己：朝着心中的目标努力奋斗！</p>
<h1 id="Linux系统编程基础"><a href="#Linux系统编程基础" class="headerlink" title="Linux系统编程基础"></a>Linux系统编程基础</h1><h2 id="Linux开发环境的配置"><a href="#Linux开发环境的配置" class="headerlink" title="Linux开发环境的配置"></a>Linux开发环境的配置</h2><ul>
<li>Linux虚拟机</li>
<li>XShell，Xftp连接软件</li>
<li>VS Code远程代码连接</li>
</ul>
<p>安装Ubuntu并安装openssh-server、net-tools:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo apt install net-tools</span><br><span class="line">ifconfig            <span class="comment"># 查看ip地址</span></span><br></pre></td></tr></table></figure>

<p>VS Code安装插件C/C++、Remote Development，配置~/.ssh/config:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host Ubuntu18-webserver</span><br><span class="line">    HostName 192.168.141.189</span><br><span class="line">    User zzmine</span><br></pre></td></tr></table></figure>

<p>刷新一下，可以看到远程ssh连接了，在窗口中打开连接，选择Linux-&gt;continue然后输入密码就可以建立连接了。</p>
<h2 id="GCC（GUN-Compiler-Collection）"><a href="#GCC（GUN-Compiler-Collection）" class="headerlink" title="GCC（GUN Compiler Collection）"></a>GCC（GUN Compiler Collection）</h2><p>GCC是由GNU开发的编程语言编译器，GNU编译器套件包括C、C++、Java、Go等。GCC支持C的许多“方言”，也可以区别不同的C语言标准。例如，使用命令行参数“-std=c99”启动GCC时，编译器支持C99标准。</p>
<p>安装GCC、G++：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<p>对C程序进行编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o app</span><br></pre></td></tr></table></figure>

<p>“-o”选项指定要生成的目标文件名称，成功生成后可以“./app”运行。</p>
<p>GCC的工作流程：预处理-&gt;编译-&gt;汇编-&gt;连接</p>
<p><img src= "/img/loading.gif" data-src="https://pic.imgdb.cn/item/63e8a02a4757feff33d94e60.webp" alt="gcc-process"></p>
<p>相关编译命令：</p>
<table>
<thead>
<tr>
<th align="center">gcc编译选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-E</td>
<td align="center">预处理指定的源文件，不进行编译</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">编译指定的源文件，但不进行汇编</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">编译、汇编指定的源文件，但不进行链接</td>
</tr>
<tr>
<td align="center">-o [file1] [file2] / <br />[file2] -o [file1]</td>
<td align="center">将文件file2编译成可执行文件file1</td>
</tr>
<tr>
<td align="center">-I directory</td>
<td align="center">指定include包含文件的搜索目录</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">在编译的时候，生成调试信息，该程序可以被调试器调试</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">在程序编译的时候，指定一个宏</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">不生成任何警告信息</td>
</tr>
<tr>
<td align="center">-Wall</td>
<td align="center">生成所有警告信息</td>
</tr>
<tr>
<td align="center">-On</td>
<td align="center">n取值0~3. 编译器的优化等级，-O0表示不优化，-O1为缺省值</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">在程序编译的时候，指定使用的库</td>
</tr>
<tr>
<td align="center">-L</td>
<td align="center">指定编译的时候，搜索的库的路径</td>
</tr>
<tr>
<td align="center">-fPIC / fpic</td>
<td align="center">生成与位置无关的代码</td>
</tr>
<tr>
<td align="center">-shared</td>
<td align="center">生成共享目标文件，通常用在建立共享库时</td>
</tr>
<tr>
<td align="center">-std</td>
<td align="center">指定c方言，如：-std=c99，gcc默认方言是GNU C</td>
</tr>
</tbody></table>
<p>gcc一般编译c文件，g++一般编译c++文件，但不是说绝对的。编译阶段，g++会调用gcc，两者是等价的，但是gcc不能自动和c++程序使用的库链接，所以通常使用g++来完成链接，且为了统一，干脆编译/链接全用g++了。</p>
<p>例如，编译时指定宏（能够方便程序的调试，调试时加debug编译发布的时候不加debug，这样就不用删去代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"defined debug..\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello GCC!!!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果编译时，不带“DEBUG”宏，就不会输出第一句话；如果这样编译，就会输出第一句话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span> -D DEBUG</span><br><span class="line">&lt;&lt;&lt;&lt;&lt; output &lt;&lt;&lt;&lt;&lt;</span><br><span class="line">defined debug..</span><br><span class="line">hello GCC!!!</span><br><span class="line">hello GCC!!!</span><br><span class="line">hello GCC!!!</span><br></pre></td></tr></table></figure>



<h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><p>库文件是一种代码仓库，它提供使用者一些可以直接拿来用的变量、函数或类。库是特殊的一种程序，不能单独运行。</p>
<p>库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
<p>库的好处：1. 代码保密；2. 方便部署和分发。</p>
<p><strong>静态库的制作与使用</strong></p>
<p>命令规则：其中加粗部分是固定的</p>
<blockquote>
<p>Linux: <strong>lib</strong>xxx<strong>.a</strong></p>
<p>Windows: <strong>lib</strong>xxx<strong>.lib</strong></p>
<p>其中的xxx就是库的名字，gcc -l（小L） 指定时只需要库的名字，不需要整个文件名</p>
</blockquote>
<p>静态库制作方式：</p>
<ol>
<li><p>gcc编译获得 .o 文件（仅 gcc -c）</p>
</li>
<li><p>将 .o 文件打包，使用 ar 工具（archive）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br><span class="line">-------------------</span><br><span class="line">r: 将文件插入备存文件中</span><br><span class="line">c: 建立备存文件</span><br><span class="line">s: 索引</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>静态库的使用：</p>
<ol>
<li><p>分级建立程序树状结构，生成静态库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|- include</span><br><span class="line">   |--- head.h</span><br><span class="line">|- lib</span><br><span class="line">   |--- libcalc.a</span><br><span class="line">|- main.c</span><br><span class="line">|- src</span><br><span class="line">   |--- add.c</span><br><span class="line">   |--- div.c</span><br><span class="line">   |--- mult.c</span><br><span class="line">   |--- sub.c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libcalc.a add.o div.o mult.o sub.o -I ..&#x2F;include&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 gcc “-I”(大i) 选项 指定自定义的头文件；“-L”(大L)选项指定库的搜索路径；“-l”(小L)选项指定所需的库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -I ./include/ -L ./lib -l calc</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>动态库的制作与使用</strong></p>
<p>命名规则：其中加粗部分是固定的</p>
<blockquote>
<p>Linux: <strong>lib</strong>xxx<strong>.so</strong>           在Linux下是一个可执行文件</p>
<p>Windows: <strong>lib</strong>xxx<strong>.dll</strong></p>
<p>其中的xxx就是库的名字，使用时只需要库的名字，不需要整个文件名</p>
</blockquote>
<p>动态库的制作方式：</p>
<ol>
<li><p>gcc获得 .o 文件，<strong>得到和位置无关的代码</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic a.c b.c [-I ../include/]</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc 得到动态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>动态库的使用：指定自定义头文件，“-L”(大L)选项指定库的搜索路径；“-l”(小L)选项指定所需的库:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -I ./include/ -L ./lib -l calc</span><br><span class="line">./main              <span class="comment"># 直接这样运行会报错</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; error &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">./main: error <span class="keyword">while</span> loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>要解决动态库加载出现的问题，就需要先了解动态库的原理：</p>
<blockquote>
<p>对于静态库，GCC进行链接时，会把静态库中代码打包到可执行程序中；</p>
<p>对于动态库，GCC进行链接时，只将动态库的信息放在程序中，动态库代码不会被打包到可执行程序中。程序启动之后，动态库会被动态加载到内存中，通过 ldd（list dynamic dependencies）命令检查动态库依赖关系。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ldd main</span><br><span class="line">-------- output --------</span><br><span class="line">linux-vdso.so.1 (0x00007ffdc2d7e000)</span><br><span class="line">libcalc.so =&gt; not found            <span class="comment"># 可以发现，自己制作的动态库是没有被找到的</span></span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f256322a000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f256381d000)</span><br></pre></td></tr></table></figure>

<p>那么如何定位共享库文件呢？</p>
<p><strong>当系统加载可执行代码时，能够知道其所依赖的库的名字，但还需要知道绝对路径</strong>。此时就需要系统的<strong><u>动态载入器（ld-linux.so）</u></strong>来获取该绝对路径。它会先后搜索可执行程序（基本都是elf格式，程序就是一个进程，OS会分配虚拟地址空间）的 DT_RPATH 段 —&gt; 环境变量（PATH） —&gt; LD_LIBRARY_PATH —&gt; /etc/ld.so.cache 文件列表 —&gt; /lib/ , /usr/lib 目录中，找到库文件后将其<em>载入内存</em>。</p>
<p>具体配置方式：</p>
<p><em>1，配置LD_LIBRARY_PATH</em></p>
<ul>
<li><p>[临时的-终端中配置] 可以使用export命令，将动态库的绝对路径添加到 LD_LIBRARY_PATH中：（其中$表示取原来的值，“:”表示拼接，等号中间不要有空格）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/home/zzmine/linux/lesson06/lib</span><br><span class="line">env                         <span class="comment"># 查看所有环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span>       <span class="comment"># 查看 LD_LIBRARY_PATH 的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[永久的-用户级别配置] 到用户起始目录 /home/zzmine 中修改 .bashrc，添加上面的export语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">...     <span class="comment"># 增加export LD_LIBRARY_PATH 语句</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>[永久的-系统级别配置]  以管理者权限在 /etc/profile 中添加以上export语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line">...     <span class="comment"># 增加export LD_LIBRARY_PATH 语句</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>2，配置 /etc/ld.so.cache</em></p>
<p>ld.so.cache 是二进制文件，不可以直接修改，但是可以间接修改 ld.so.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line">...      <span class="comment"># 将所需动态库的绝对路径直接加进去</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>不建议将自己的动态库文件放到 /lib/ 或者 /usr/lib/ 中，以防与系统自带的动态库发生冲突。</p>
<p><strong>静态库与动态库的优缺点</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>静态库</td>
<td>1，静态库打包到应用程序中加载速度快；<br />2，发布程序无需提供静态库，移植方便。</td>
<td>1，消耗系统资源，浪费内存（不同程序需要同一静态库，会占用多份内存空间）；<br />2，更新、部署、发布麻烦。</td>
<td>库比较小</td>
</tr>
<tr>
<td>动态库</td>
<td>1，可以实现进程间资源共享；<br />2，更新、部署、发布简单；<br />3，可以控制何时加载动态库。</td>
<td>1，加载速度比静态库慢（但相差也不多）；<br />2，发布程序时需要提供依赖的动态库。</td>
<td>库比较大</td>
</tr>
</tbody></table>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，就可以自动编译整个工程。 </p>
<p><strong>Makefile文件命名和规则</strong></p>
<p>文件命名：makefile 或者 Makefile</p>
<p>Makefile规则：</p>
<ul>
<li><p><u>一个Makefile文件中可以有一个或多个规则</u>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标 ...: 依赖 ...</span><br><span class="line">	命令（Shell命令）</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>目标：最终要生成的文件（伪目标除外）</p>
<p>依赖：生成目标所需要的文件或是目标</p>
<p>命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进）</p>
</li>
<li><p><u>Makefile中的其他规则一般都是为第一条规则服务的</u>。如果下面的规则与第一条没有关系，就不会执行，除非手动指定目标。</p>
</li>
</ul>
<p><strong>Makefile工作原理</strong></p>
<ul>
<li><p><u>命令执行之前，需要检查规则中的依赖是否存在</u>。</p>
<p>若存在，执行命令；</p>
<p>若不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令。</p>
</li>
<li><p><u>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</u>。</p>
<p>如果依赖的时间比目标的时间晚，需要重新生成目标；</p>
<p>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行。</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: sub.o add.o mult.o div.o main.o</span></span><br><span class="line">	gcc sub.o add.o mult.o div.o main.o -o app</span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">mult.o: mult.c</span></span><br><span class="line">	gcc -c mult.c -o mult.o</span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">	gcc -c div.c -o div.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>

<p>如果生成app之后，又修改了main.c，那么再次make仅会重新生成目标 main.o 和 app。</p>
<p><strong>Makefile中的变量</strong></p>
<p>上面的Makefile文件执行效率较高，但是写起来会很麻烦，有许多文件时需要写很多单独的语句。要进一步提高效率就需要了解Makefile中的变量。</p>
<ul>
<li><p>自定义变量：没有数据类型，仅字符串</p>
<p>变量名=变量值</p>
</li>
<li><p>预定义变量：系统已经定义好</p>
<p>AR：归档维护程序的名称，默认值为ar</p>
<p>CC：C编译器的名称，默认值为cc</p>
<p>CXX：C++编译器的名称，默认值为g++</p>
<p>$@：目标的完整名称（包括后缀）</p>
<p>$&lt;：第一个依赖文件的名称</p>
<p>$^：所有依赖文件</p>
</li>
<li><p>获取变量的值</p>
<p>$(变量名)</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动变量只能在规则的命令中使用</span></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">src=sub.o add.o mult.o div.o main.o</span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">     <span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>

<p><strong>模式匹配</strong></p>
<p>%.o: %.c</p>
<p>%是通配符，匹配一个字符串，两个%匹配的是同一个字符串，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p><strong>函数</strong></p>
<p>如果想自动获取src变量的值，就要使用到Makefile中函数的功能，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br><span class="line">功能：获取指定目录下指定类型的文件列表</span><br><span class="line">参数：PATTERN指的是某个或多个目录下对应的某种类型的文件，如果有多个目录，一般用空格间隔</span><br><span class="line">返回：得到若干个文件的文件列表，文件名之间使用空格间隔</span><br><span class="line">示例：</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c ./sub/*.c)</span></span><br><span class="line">返回值格式： a.c b.c c.c d.c e.c</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line">功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换</span><br><span class="line">&lt;pattern&gt;可以包括通配符'%'，表示任意长度的字符串。如果&lt;replacement&gt;中也包含'%'，那么&lt;replacement&gt;中的'%'就是&lt;pattern&gt;中'%'所代表的字符串</span><br><span class="line">返回：被替换后的字符串</span><br><span class="line">示例：</span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c bar.c)</span></span><br><span class="line">返回值格式：x.o bar.o</span><br></pre></td></tr></table></figure>

<p>那么，上面例子的最终版Makefile将如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean          # 伪目标，防止存在clean文件导致无法执行clean目标</span></span><br><span class="line"><span class="section">clean:               </span></span><br><span class="line">	rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure>



<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><p>GDB是由GNU软件系统社区提供的调试工具。</p>
<p>通常在为调试而编译时，会关闭编译器的优化选项（’-O’），并打开调试选项（’-g’）。另外，’-Wall’在尽量不影响程序行为的情况下打开所有warning，也可以发现许多问题，避免一些不必要的BUG。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -Wall program.c -o program</span><br></pre></td></tr></table></figure>

<p>‘-g’选项的作用是在可执行文件中加入源代码的信息，例如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p>
<p><strong>GBD命令——启动、退出、查看代码</strong></p>
<ul>
<li><p>启动和退出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb 可执行程序</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
</li>
<li><p>给程序设置参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args 10 20</span><br><span class="line">show args</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用帮助：help</p>
</li>
<li><p>查看当前文件代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list/l (从默认位置显示，10行)</span><br><span class="line">list/l 行号 (从指定的行显示，指定行在中间)</span><br><span class="line">list/l 函数名 (从指定函数显示)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看非当前文件代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list/l 文件名:行号</span><br><span class="line">list/l 文件名:函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置显示的行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show list/listsize</span><br><span class="line"><span class="built_in">set</span> list/listsize 行数</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>GDB命令——断点</strong></p>
<ul>
<li><p>设置断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b&#x2F;break 行号</span><br><span class="line">b&#x2F;break 函数名</span><br><span class="line">b&#x2F;break 文件名:行号</span><br><span class="line">b&#x2F;break 文件名:函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看断点：i/info b/break</p>
</li>
<li><p>删除断点: d/del/delete 断点编号</p>
</li>
<li><p>设置断点无效：dis/disable 断点编号</p>
</li>
<li><p>设置断点生效：ena/enable 断点编号</p>
</li>
<li><p>设置条件断点（一般用在循环的位置）：b/break 10 if i==5</p>
</li>
</ul>
<p><strong>GDB命令——调试</strong></p>
<ul>
<li><p>运行GDB程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start (程序停在第一行)</span><br><span class="line">run (遇到断点才停)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续运行，到下一个断点停: c/continue</p>
</li>
<li><p>向下执行一行代码（不会进入函数体）: n/next</p>
</li>
<li><p>变量操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p&#x2F;print 变量名 （打印变量值）</span><br><span class="line">ptype 变量名 （打印变量类型）</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下单步调试（遇到函数进入函数体）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s&#x2F;step</span><br><span class="line">finish（跳出函数体）</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动变量操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display 变量名 (自动打印指定变量的值)</span><br><span class="line">i&#x2F;info display</span><br><span class="line">undisplay 编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set var 变量名&#x3D;变量值</span><br><span class="line">until （跳出循环）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src= "/img/loading.gif" data-src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788015668/798C7A2D023204559B62F88B54E35CBB" alt=""></p>
<p>内核空间中有进程控制块PCB，其中包含文件描述符表（默认大小1024），前3个文件描述符是默认的（标准输入，标准输出，标准错误）。后面每打开一个新文件，就占用一个文件描述符，且是空闲的最小的一个文件描述符。</p>
<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="TCP-IP协议详解"><a href="#TCP-IP协议详解" class="headerlink" title="TCP/IP协议详解"></a>TCP/IP协议详解</h2><p>TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层以及应用层。上层协议使用下层协议提供的服务。  </p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/27/c5uY7gPlBNtaK1C.png" alt="TCP/IP协议栈"></p>
<ul>
<li>数据链路层【帧】：<strong>实现了网卡接口的网络驱动程序，以及处理数据在物理媒介（比如以太网、令牌环等）上的传输。</strong>常用协议有：<strong>ARP</strong>（Address Resolve Protocol, 地址解析协议）以及<strong>RARP</strong>（Reverse ARP, 逆地址解析协议）</li>
<li>网络层【数据报】：<strong>实现数据报的选路和转发</strong>。核心协议为<strong>IP协议</strong>（Internet Protocol, 因特网协议），IP协议使用逐跳（hop by hop）的方式确定通信路径。还有一个重要协议为<strong>ICMP协议</strong>（Internet Control Message Protocol, 因特网控制报文协议），用于检测网络连接。</li>
<li>传输层【报文段】：<strong>为两台主机上的应用程序提供端到端（end to end）的通信</strong>。主要有三个协议：<strong>TCP协议</strong>（Transmission Control Protocol, 传输控制协议），为应用层提供可靠的、面向连接的和基于流（steam）的服务；<strong>UDP协议</strong>（User Datagram Protocol, 用户数据报协议），为应用层提供不可靠、无连接和基于数据报的服务；以及<em>SCTP协议</em>（Stream Control Transmission Protocol, 流控制传输协议）。</li>
<li>应用层：<strong>处理应用程序的逻辑</strong>。数据链路层、网络层和传输层负责处理网络通信的细节，在内核空间中完成。而应用层负责处理众多逻辑，比如文件传输和网络管理等，在用户空间实现。应用层协议用很多，列举一些：<strong>ping</strong>，<strong>telnet</strong>，<strong>OSPF</strong>（Open Shortest Path First, 开放最短路径优先），<strong>DNS</strong>（Domain Name Service, 域名服务）</li>
</ul>
<p>上层协议是如何使用下层协议提供的服务的呢？这是通过<strong>封装</strong>（encapsulation）实现的，封装指的是：</p>
<blockquote>
<p>应用程序数据在发送到物理网络之前，将沿着协议栈从上往下依次传递。</p>
<p>每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能。</p>
</blockquote>
<p>帧是最终在物理网络上传输的字节序列，当帧到达目的主机时，将沿协议栈自底向上依次传递。各层协议栈处理帧中本层负责的头部数据，以获取所需信息，并最终将处理后的帧交给目标应用程序。这个过程成为<strong>分用</strong>（demultiplexing），即具体的使用下层服务的过程。</p>
<p><strong>以太网帧</strong>（注意，物理网络上还有其他类型的帧）的MTU（Max Transmit Unit，最大传输单元）为1500. 其封装格式如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/09/chDabI2RLQAJPOS.jpg" alt="以太网帧封装.png"></p>
<p>由于数据链路层、网络层、传输层协议是在内核中实现的，因而操作系统需要一组系统调用，使应用程序能够访问这些协议提供的服务，这组系统调用就是<code>socket</code>。</p>
<p><code>socket</code>是一套通用网络编程接口，不但可以访问内核中的TCP/IP协议栈，还可以访问其他网络协议栈（比如X.25协议栈，UNIX本地域协议栈等）。</p>
<h3 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h3><p>ARP协议能实现任意 网络层地址 到 物理地址 的转换。【本书只讨论从 IP地址 到 以太网MAC地址】</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><blockquote>
<p>主机向自己所在的网络 广播 一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>
</blockquote>
<h4 id="ARP请求-响应报文格式"><a href="#ARP请求-响应报文格式" class="headerlink" title="ARP请求/响应报文格式"></a>ARP请求/响应报文格式</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/09/zS3O2ZAdw6qyiuH.png" alt="aWflZktp12xQMqv.png"></p>
<p>前面三个部分为以太网帧的首部，后面才是ARP报文。</p>
<h4 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h4><p>通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</p>
<p>Linux中有如下相关命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo arp -a								<span class="comment"># 显示arp缓存</span></span><br><span class="line">$ sudo arp -d &lt;ip地址&gt;					   <span class="comment"># 删除对应arp缓存项</span></span><br><span class="line">$ sudo arp -s &lt;ip地址&gt; &lt;MAC地址&gt;			  <span class="comment"># 添加对应arp缓存项</span></span><br></pre></td></tr></table></figure>

<p>还可以使用<code>tcpdump</code>命令来观察ARP通信的过程。</p>
<h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><p>我们通常使用域名而不是IP地址来访问机器，那么如何将域名转化为IP地址呢？这就需要使用 域名查询服务。该服务有多种实现方式，比如NIS（Network Information Service, 网络信息服务），DNS和本地静态文件（hosts文件）。而这里主要讨论DNS。</p>
<p>DNS是一套分布式的域名服务系统，每个DNS服务器上都存放着大量的机器名称和IP地址的映射，并且是动态更新的。</p>
<h4 id="DNS查询和应答报文"><a href="#DNS查询和应答报文" class="headerlink" title="DNS查询和应答报文"></a>DNS查询和应答报文</h4><p>（略，见1.6.1）</p>
<h4 id="Linux下访问DNS服务"><a href="#Linux下访问DNS服务" class="headerlink" title="Linux下访问DNS服务"></a>Linux下访问DNS服务</h4><p>Linux使用<code>/etc/resolv.conf</code>文件来存放DNS服务器的IP地址。</p>
<p>一个常用的访问DNS服务器的客户端程序是<code>host</code>，比如向DNS服务器查询<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ host -t A www.baidu.com</span><br><span class="line">www.baidu.com is an <span class="built_in">alias</span> <span class="keyword">for</span> www.a.shifen.com.</span><br><span class="line">www.a.shifen.com has address 14.215.177.38</span><br><span class="line">www.a.shifen.com has address 14.215.177.39</span><br></pre></td></tr></table></figure>

<p>使用<code>tcpdump</code>来抓包，观察DNS通信过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i ens33 -nt -s 500 port domain</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 500 bytes</span><br><span class="line"></span><br><span class="line">$ host -t A www.baidu.com</span><br><span class="line">IP 192.168.141.137.53999 &gt; 192.168.141.2.53: 62675+ A? www.baidu.com. (31)</span><br><span class="line">IP 192.168.141.2.53 &gt; 192.168.141.137.53999: 62675 3/0/0 CNAME www.a.shifen.com., A 14.215.177.38, A 14.215.177.39 (90)</span><br></pre></td></tr></table></figure>





<h2 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h2><p>IP协议是TCP/IP协议族的核心协议，本章将从（1）IP头部信息以及（2）IP数据报的路由和转发，两个方面来深入探讨IP协议。在开始谈论前，先简单介绍一下IP服务。 </p>
<p><strong>IP服务的特点： 为上层协议提供无状态、无连接、不可靠的服务。</strong></p>
<ul>
<li><p>无状态：<u>IP通信双方不同步传输数据的状态信息</u>，因此所有IP数据报的发送、传输和接收都是相互独立的。</p>
<p>优点：简单，高效</p>
<p>缺点：无法处理乱序和重复的IP数据报</p>
</li>
<li><p>无连接：<u>IP通信双方都不长久地维持对方的任何信息</u>，因此上层协议每次发送数据报的时候，都必须指定对方的IP地址。</p>
</li>
<li><p>不可靠：<u>不能保证IP数据报准确地到达接收端</u>，可能因超时发送失败，也有可能校验发现数据不正确，因此使用IP服务的上层协议（如TCP）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
</li>
</ul>
<h3 id="弄清网络地址，主机地址以及子网掩码的区别"><a href="#弄清网络地址，主机地址以及子网掩码的区别" class="headerlink" title="弄清网络地址，主机地址以及子网掩码的区别"></a>弄清网络地址，主机地址以及子网掩码的区别</h3><p>IP地址，是指互联网协议地址。IPv4地址是一个32位的二进制数，IPv6是一个128位的地址。IPv4通常用<code>点分十进制</code>的方式来表示，一个十进制数表示8个bit（如，192.168.1.1是二进制 11000000 10101000 00000001 00000001）。</p>
<p>IP地址的组成：<strong>网络号</strong>+<strong>主机号</strong></p>
<p>而<strong>子网掩码</strong>，就是用来划分网络号和主机号。<strong>IP地址与子网掩码进行按位与操作，就能得到网络地址</strong>。通过该方式得到的网络地址相同，则说明两个IP地址处于同一个网络中，可以直接通信；否则，需要设置网关来进行通信。</p>
<p>举例：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
<th>二进制形式</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>192.168.1.108</td>
<td>11000000 10101000 00000001 01101100</td>
</tr>
<tr>
<td>子网掩码</td>
<td>255.255.255.0</td>
<td>11111111 11111111 11111111 00000000</td>
</tr>
<tr>
<td>网络地址</td>
<td>192.168.1.0</td>
<td>11000000 10101000 00000001 00000000</td>
</tr>
</tbody></table>
<p>而IP地址通常可以分为五类：</p>
<table>
<thead>
<tr>
<th>IP类别</th>
<th>网络标识</th>
<th>可支持的网络数目</th>
<th>主机标识</th>
<th>每个网络支持的主机数</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>前8位（左前1为<strong>0</strong>）</td>
<td>2^7-1-1=126</td>
<td>后24位</td>
<td>2^24-2=16,777,214</td>
</tr>
<tr>
<td>B类</td>
<td>前16位（左前2为<strong>10</strong>）</td>
<td>2^14-1=16383</td>
<td>后16位</td>
<td>2^16-2=65,534</td>
</tr>
<tr>
<td>C类</td>
<td>前24位（左前三为<strong>110</strong>）</td>
<td>2^21-1=2097151</td>
<td>后8位</td>
<td>2^8-2=254</td>
</tr>
</tbody></table>
<p>特殊类：</p>
<table>
<thead>
<tr>
<th>IP类别</th>
<th>网络标识</th>
<th>可支持的网络范围</th>
</tr>
</thead>
<tbody><tr>
<td>D类</td>
<td>前4位为1110</td>
<td>224.0.0.0~239.255.255.255，D类地址用于组播（multicasting）</td>
</tr>
<tr>
<td>E类</td>
<td>前4位为1111</td>
<td>240.0.0.0~255.255.255.254，E类地址为保留地址</td>
</tr>
</tbody></table>
<p>Tip:</p>
<ol>
<li><p>关于可支持的网络数目：</p>
<blockquote>
<p>每个类别的IP，网络号全0的地址不可分配，所以都需要减1</p>
<p>A类地址网络号全1时为127.x.x.x，但是该地址作为回环地址，不可使用，故还要减了1</p>
</blockquote>
</li>
<li><p>关于每个网络支持的主机数：</p>
<blockquote>
<p>主机号全0或全1的地址不可分配，所以都需要减2</p>
</blockquote>
</li>
</ol>
<p>其中A，B，C三类地址中各保留了一个区域作为私网地址，即供局域网使用。私网地址不能在公网上出现，只能用在内部网路中，所有路由器都不能发送目标地址为私网地址的数据报。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A类私网地址：10.0.0.0 ~ 10.255.255.255</span><br><span class="line">B类私网地址：172.16.0.0 ~ 172.31.255.255</span><br><span class="line">C类私网地址：192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure>



<h3 id="IPv4头部结构"><a href="#IPv4头部结构" class="headerlink" title="IPv4头部结构"></a>IPv4头部结构</h3><p>IPv4头部结构如图所示，其长度通常为20字节，除非含有可变长的选项部分。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/09/sMxo2bKGA7prYSt.jpg" alt="IPv4_head.png"></p>
<ul>
<li>4位版本号：制定IP协议的版本，对IPv4来说，值是4。</li>
<li>4位头部长度：标识该IP头部有多少个<em>32bit（4字节）</em>，最多有15个4字节，即最多60字节。</li>
<li>8位服务类型（TOS）：包括一个3位的优先权字段（现已被忽略），4位TOS字段和一位保留字段（必须置0）。4位TOS分别表示：最小延迟，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1。</li>
<li>16位总长度：指整个IP数据报的长度，以字节为单位，因此<strong>IP数据报的最大长度为65535(2^16-1)字节</strong>。但是由于帧的MTU限制，长度超过MTU的数据报都将被分片传输。</li>
<li>16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据报，其值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具有相同的标识值。</li>
<li>3位标志：第一位保留；第二位（Don’t Fragment, DF）表示“禁止分片”，如果设置这个位，IP模块将不对数据报进行分片，长度超过MTU则丢弃并返回一个ICMP差错报文。第三位（More Fragment, MF）表示“分更多分片”，除了数据报的最后一个分片外，其他分片这一位都要置1.</li>
<li>13位分片偏移：分片相对于原始IP数据报开始处的偏移。实际的偏移值都是该值乘8得到的，所以除最后一个IP分片外，每个IP分片的数据部分长度必须是8的整数倍。</li>
<li>8位生存时间（Time To Live, TTL）：是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置（通常是64）。数据报在转发过程中没经过一个路由，该值就被路由器减1. 当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。<strong>TTL值可以防止数据报陷入路由循环</strong>。</li>
<li>8位协议：用来区分上层协议。<code>/etc/protocols</code>文件定义了所有上层协议对应的protocol字段的数值。其中ICMP是1，TCP是6，UDP是17. 【<code>/etc/services</code>文件定义了应用程序的端口号】</li>
<li>16位头部校验和：由发送端填充，接收端使用CRC算法以检验IP数据报<strong>头部</strong>在传输过程中是否损坏。</li>
<li>32位源端和目的端IP地址：标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变。</li>
<li>可用的IP选项包括：记录路由（记录经过的路由器）；时间戳（记录被转发的时间）；松散源路由选择（指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器）；严格源路由选择（指定路由IP地址列表，数据报只能经过被指定的路由器）</li>
</ul>
<h4 id="使用tcpdump观察IPv4头部结构"><a href="#使用tcpdump观察IPv4头部结构" class="headerlink" title="使用tcpdump观察IPv4头部结构"></a>使用tcpdump观察IPv4头部结构</h4><p>为了深入理解IPv4头部中每个字段的含义，我们利用<code>tcpdump</code>抓取telnet服务的数据报：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -ntx -i lo</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"></span><br><span class="line">$ telnet 127.0.0.1      <span class="comment"># 开另一个终端执行</span></span><br><span class="line"></span><br><span class="line">IP 127.0.0.1.46024 &gt; 127.0.0.1.23: Flags [S], seq 2327807816, win 32792, options [mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6], length 0</span><br><span class="line">	0x0000:  4510 003c 0995 4000 4006 3315 7f00 0001</span><br><span class="line">	0x0010:  7f00 0001 b3c8 0017 8abf 8748 0000 0000</span><br><span class="line">	0x0020:  a002 8018 fe30 0000 0204 400c 0402 080a</span><br><span class="line">	0x0030:  026e 44d9 0000 0000 0103 0306</span><br></pre></td></tr></table></figure>

<p>【提示】如果telnet 127.0.0.1 出现 <code>telnet: Unable to connect to remote host: Connection refused</code>，那么可以检查一下telnet是否启动。见：<a href="https://www.jianshu.com/p/7231d48c3159" target="_blank" rel="noopener">解决Ubuntu中telnet 127.0.0.1时Unable to connect to remote host: Connection refused的问题 - 简书 (jianshu.com)</a></p>
<p>开启了抓包的 <code>-x</code> 选项，将数据数据包的二进制内容。此数据包共60字节，前20为IP头部，后40为TCP头部，不含应用程序数据（length为0）。</p>
<table>
<thead>
<tr>
<th>十六进制数</th>
<th>二进制数/十进制数</th>
<th>IP头部信息说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x4</td>
<td>4</td>
<td>IP版本号(IPv4为4)</td>
</tr>
<tr>
<td>0x5</td>
<td>5</td>
<td>头部长度5个32位，即20字节</td>
</tr>
<tr>
<td>0x10</td>
<td>‘0001 0000</td>
<td>TOS选项中最小延时被开启</td>
</tr>
<tr>
<td>0x003c</td>
<td>60</td>
<td>数据报总长度60字节</td>
</tr>
<tr>
<td>0x0995</td>
<td></td>
<td>数据报标识</td>
</tr>
<tr>
<td>0x4</td>
<td>‘0100</td>
<td>设置了禁止分片</td>
</tr>
<tr>
<td>0x000</td>
<td>0</td>
<td>分片偏移为0</td>
</tr>
<tr>
<td>0x40</td>
<td>64</td>
<td>TTL为64</td>
</tr>
<tr>
<td>0x06</td>
<td>6</td>
<td>协议字段为6，对应上层协议为TCP</td>
</tr>
<tr>
<td>0x3315</td>
<td></td>
<td>IP头部校验和</td>
</tr>
<tr>
<td>0x7f00 0001</td>
<td></td>
<td>32位源端IP：127.0.0.1</td>
</tr>
<tr>
<td>0x7f00 0001</td>
<td></td>
<td>32位目的端IP：127.0.0.1</td>
</tr>
</tbody></table>
<p>由此可见，telnet选择使用具有最小延时的服务。</p>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p><strong>当IP数据报的长度超过帧的MTU时，它将被分片传输</strong>。而分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。</p>
<p>通过<code>数据报标识</code>、<code>标志</code>和<code>分片偏移</code>这三个字段的信息，可以完成IP的分片和重组。</p>
<p>一个IP数据包的每个分片都具有自己的IP头部，它们具有先相同的标识值，但片偏移不同。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU为1500字节，因此它携带的IP数据报的数据部分最多是1480字节（头部占20字节时）。假设一个长度为1481字节的ICMP报文（包含8字节的ICMP头部，以及数据部分1473字节），则该数据报在使用以太网帧传输时必须要被分片，如下图所示。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/09/8blYZ9A5tRUIH2z.jpg" alt="IP数据报被分片.png"></p>
<p>使用tcpdump来验证这一分片的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -ntv -i eth0 icmp</span><br><span class="line">$ ping kongming20 -s 1473         <span class="comment"># -s指定每次发送1473字节的数据</span></span><br><span class="line"></span><br><span class="line">IP (tos 0x0, ttl 64, id 61197, offset 0, flags [+], proto ICMP (1), length 1500)</span><br><span class="line">    192.168.1.108 &gt; 192.168.1.110: ICMP <span class="built_in">echo</span> request, id 41737, seq 1, length 1480</span><br><span class="line">IP (tos 0x0, ttl 64, id 61197, offset 1480, flags [none], proto ICMP (1), length 21)</span><br><span class="line">    192.168.1.108 &gt; 192.168.1.110: ICMP</span><br></pre></td></tr></table></figure>

<p>可以看到，两个分片标识都是一样的，为<code>61197</code>，说明是同一个数据报的分片；第一个分片的偏移(offset)为<code>0</code>，而第二个为<code>1480</code>；第一个分片的<code>flags [+]</code>表示MF标志，即更多分片，而第二个分片则没有设置标志；两个分片的长度分别为<code>1500</code>和<code>21</code>字节。</p>
<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><p>IP协议的一个核心任务是数据报的路由，即决定<strong>发送数据报到目标机器的路径</strong>。</p>
<p>先简要分析IP模块的基本工作流程。</p>
<h4 id="IP模块工作流程"><a href="#IP模块工作流程" class="headerlink" title="IP模块工作流程"></a>IP模块工作流程</h4><p>IP模块基本工作流程如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/10/aCwjmgtYu4RUcZv.jpg" alt="IP模块基本工作流程.jpg"></p>
<p>从右往左看，IP模块接到来自数据链路层的IP数据报时，首先对头部进行<code>CRC校验</code>，确认无误后分析头部信息。</p>
<p>如果数据报设置了源站选路选项（松散源路由选择或严格源路由选择），则IP模块调用<code>数据报转发子模块</code>来处理该数据报。如果数据报目标IP地址是本机的某个IP或者广播地址，就根据头部中的协议字段将它派分到对应的上层应用（分用）。如果数据报不是发到本机的，就调用<code>数据报转发子模块</code>来处理。</p>
<p><code>数据报转发子模块</code>首先检测系统是否允许转发，如果不允许就将数据报丢弃，否则经过一些操作后交给<code>数据报输出子模块</code>。</p>
<p>IP模块实现数据报路由的核心数据结构是<code>路由表</code>。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器）。</p>
<p>IP输出队列存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（ICMP报文、TCP报文段和UDP数据报）的IP数据报。</p>
<h4 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h4><p>可以使用<code>route</code>命令或者<code>netstat</code>命令来查看路由表，以下是<code>route</code>命令的输出内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         192.168.1.1     0.0.0.0         UG    0      0      eth0</span><br><span class="line">192.168.1.0     *               255.255.255.0   U     1      0      eth0</span><br></pre></td></tr></table></figure>

<p>该路由表包括两项，每项都有8个字段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Destination</td>
<td>目标网络或主机</td>
</tr>
<tr>
<td>Gateway</td>
<td>网关地址，*表示目标和本机在同一网络，不需要路由</td>
</tr>
<tr>
<td>Genmask</td>
<td>网络掩码</td>
</tr>
<tr>
<td>Flags</td>
<td>路由项标志，常见的标志有如下5种：<br />1，U：该路由项是活动的；<br />2，H：该路由项的目标是一台主机；<br />3，G：该路由项的目标是网关；<br />4，D：该路由项是由重定向生成的；<br />5，M：该路由项被重定向修改过</td>
</tr>
<tr>
<td>Metric</td>
<td>路由距离，即到达指定网络所需的中转数</td>
</tr>
<tr>
<td>Ref</td>
<td>路由项被引用的次数（Linux未使用）</td>
</tr>
<tr>
<td>Use</td>
<td>该路由项被使用的次数</td>
</tr>
<tr>
<td>Iface</td>
<td>该路由项对应的输出网卡接口</td>
</tr>
</tbody></table>
<p>以上路由表中的第一条记录，目标地址为<code>default</code>，即所谓的默认路由项。第二条路由项的目标地址为<code>192.168.1.0</code>，指的是本地局域网，网关地址为<code>*</code>，说明数据报不需要路由中转，是直达的。</p>
<p>IP路由的匹配机制：</p>
<ol>
<li>查找路由表中和数据报的目标IP地址完全匹配的项</li>
<li>查找与数据报的目标IP地址具有相同网络号的网络IP地址（如第二项）</li>
<li>选择默认路由项</li>
</ol>
<h4 id="路由表更新"><a href="#路由表更新" class="headerlink" title="路由表更新"></a>路由表更新</h4><p>路由表必须能够更新，以反映网络连接的变化。使用<code>route</code>命令可以修改路由表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo route add -host 192.168.1.109 dev eth0</span><br><span class="line">$ sudo route del -net 192.168.1.0 netmask 255.255.255.0</span><br><span class="line">$ sudo route del default</span><br><span class="line">$ sudo route add default gw 192.168.1.109 dev eth0</span><br></pre></td></tr></table></figure>

<p>其中，第一行表示添加主机<code>192.168.1.109</code>对应的路由项，所有到该主机的IP数据报将通过网卡eth0传输。第二行表示删除网络<code>192.168.1.0</code>对应的路由项，结果是无法访问局域网上的任何机器（除刚刚添加192.168.1.109）。第三行表示删除默认路由项。第四行表示添加默认路由项，不过网关为<code>192.168.1.109</code>，而不是可以直接访问因特网的路由器。</p>
<p>修改后的路由表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.1.109   *               255.255.255.255 UH    0      0      eth0</span><br><span class="line">default         192.168.1.109   0.0.0.0         UG    0      0      eth0</span><br></pre></td></tr></table></figure>

<p>注意，新的路由项<code>Flags</code>也不同，其中第一条中的<code>Flags</code>为<code>UH</code>，表示主机路由项。</p>
<p>通过route命令或其他工具手工修改路由表，是静态的路由更新方式。对于大型路由器，他们通常通过BGP（Border Gateway Protocol, 边际网关协议）、RIP（Routing Information Protocol, 路由信息协议）、OSPF等协议来发现路径，并更新自己的路由表。</p>
<h4 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h4><p>之前提到，不发送给本机的IP数据报将由<code>数据报转发子模块</code>来处理。路由器可以转发数据报，但主机一般只发送和接收数据报，这是因为主机上<code>/proc/sys/net/ipv4/ip_forward</code>内核参数默认被设置为0。我们可以通过修改该参数来启用主机数据报转发（root身份执行）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &gt; 1 /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>对于允许IP数据报转发的系统（路由器或主机），<code>数据报转发子模块</code>将对期望转发的数据报执行以下操作：</p>
<ol>
<li>检查数据报头部TTL值。0则丢弃。</li>
<li>查看数据报头部的严格源路由选项。如果被设置，则检测数据报的目标IP地址是否为本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</li>
<li>如果有必要，给源端发送一个ICMP重定向报文，告诉它一个更合理的下一跳路由器。</li>
<li>将TTL值减1。</li>
<li>处理IP头部选项。</li>
<li>如果有必要，执行IP分片操作。</li>
</ol>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>IP模块基本流程图中显示，ICMP重定向报文也能更新路由表，这里就简要讨论一下。</p>
<p><strong>ICMP重定向报文</strong></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/11/YqtiDUjLN9Fp4fm.jpg" alt="ICMP重定向报文.jpg"></p>
<p>ICMP重定向报文的类型值是5，代码字段有4个可选值（0-3），用来区分不同的重定向类型，本文讨论主机重定向，其代码值为1。</p>
<p>该报文给接收方提供了如下两个信息：</p>
<ol>
<li>引起重定向的IP数据报的源端IP地址（IP数据报头部信息中）</li>
<li>应该使用的路由器的IP地址</li>
</ol>
<p>接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用那个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。</p>
<p><code>/proc/sys/net/ipv4/conf/all/send_redirects</code>内核参数指定是否允许发送ICMP重定向报文，而<code>/proc/sys/net/ipv4/conf/all/accept_redirects</code>内核参数则指定是否允许接收ICMP重定向报文。一般来说，主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文。</p>
<h2 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h2><p>传输层协议主要有两个：TCP协议和UDP协议。TCP相对于UDP的特点是：<strong>面向连接</strong>、<strong>字节流</strong>和<strong>可靠传输</strong>。</p>
<ol>
<li><p>面向连接。</p>
<p>使用TCP通信的双方必须先建立连接，然后才能开始数据的读写。</p>
<p>TCP连接是<strong>全双工</strong>的，即双方的数据读写可以通过一个连接进行。</p>
<p>TCP连接是一对一的，所以基于广播或多播（目标是多个主机地址）的应用程序不能使用TCP服务。</p>
</li>
<li><p>字节流。</p>
<p>TCP发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系。</p>
<p>而UDP发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送，接收端必须及时针对每一个UDP数据报执行读操作。</p>
</li>
<li><p>可靠传输。</p>
<p>TCP协议采用<strong>发送应答</strong>机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。</p>
<p>TCP协议采用<strong>超时重传</strong>机制，发送端在发送出一个报文段之后会启动定时器，如果在定时时间内未收到应答，它将重发该报文段。</p>
<p>会对接到的TCP报文段重排、整理（因为TCP报文段最终是以IP数据报发送的），再交给应用层。</p>
</li>
</ol>
<p>这一章从以下四个方面来讨论TCP协议：</p>
<ul>
<li><p>TCP头部信息。</p>
<p>用l于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。</p>
</li>
<li><p>TCP状态转移过程。</p>
<p>TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。</p>
</li>
<li><p>TCP数据流。</p>
<p>讨论两种类型的TCP数据流：交互数据流和成块数据流。</p>
</li>
<li><p>TCP数据流的控制。</p>
<p>为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。主要讨论超时重传和拥塞控制。</p>
</li>
</ul>
<h3 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h3><h4 id="固定头部结构"><a href="#固定头部结构" class="headerlink" title="固定头部结构"></a>固定头部结构</h4><p>TCP头部结构如下，其中诸多字段为管理TCP连接和控制数据流提供了足够的信息。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/12/fu8IK3ijUoZwDFO.jpg" alt="TCP头部结构.png"></p>
<ul>
<li>16位端口号：表示该报文段的源端和目的端端口号。TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（见<code>/etc/services</code>文件）。</li>
<li>32位序号：一次TCP通信过程中某个传输方向上的字节流的每个字节的编号。<em>序号值被系统初始化为某个随机值ISN</em>（Initial Sequence Number），后续TCP报文段的序号值为ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。</li>
<li>32位确认号：用作对源端发送来的TCP报文段的响应。<em>其值为收到的TCP报文段序号值加 1</em>。</li>
<li>4位头部长度：表示该TCP头部有多少个32bit（4字节）。TCP头部最长为60字节。</li>
<li>6位标志分别是：<ul>
<li>URG标志：表示紧急指针是否有效。</li>
<li>ACK标志：表示确认号是否有效。携带ACK标志的TCP报文段为<code>确认报文段</code>。</li>
<li>PSH标志：提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。</li>
<li>RST标志：表示要求对方重新建立连接。携带RST标志的TCP报文段为<code>复位报文段</code>。</li>
<li>SYN标志：表示请求建立一个连接。携带SYN标志的TCP报文段为<code>同步报文段</code>。</li>
<li>FIN标志：表示通知对方本端要关闭连接了。携带FIN标志的TCP报文段为<code>结束报文段</code>。</li>
</ul>
</li>
<li>16位窗口大小：是TCP流量控制的一个手段。接收通告窗口（Receiver Window, RWND）告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li>16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法校验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这是TCP可靠传输的一个重要保障。</li>
<li>16位紧急指针：一个正的偏移量。它和序号相加表示最后一个紧急数据的下一字节的序号。</li>
</ul>
<h4 id="TCP头部选项"><a href="#TCP头部选项" class="headerlink" title="TCP头部选项"></a>TCP头部选项</h4><p>TCP头部最后一个选项字段是可变长的可选信息。这部分最多包含40字节。TCP头部选项的一般结构如下：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/12/Mi3mpDqBcwLO2Wt.png" alt="TCP头部选项一般结构.png"></p>
<p>第一个kind字段说明选项的类型。有的TCP选项没有后面两个字段。第二个length字段指定该选项的总长度，该长度包括kind和length占据的2字节。第三个info是选项的具体信息。</p>
<p>常见的TCP选项有7种：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/12/ED1narbjzAVOoXF.jpg" alt="常见TCP头部选项.png"></p>
<p>kind=0是<strong>选项表结束</strong>选项。</p>
<p>kind=1是<strong>空操作（nop）</strong>选项。一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind=2是<strong>最大报文段长度</strong>选项。TCP连接初始化时（同步报文段），通信双方用该选项协商最大报文段长度（Max Segment Size, MSS）。TCP模块通常将MSS设置为（MTU-40）字节，减去的为TCP和IP的头部各20字节。</p>
<p>kind=3是<strong>窗口扩大因子</strong>选项。也是在同步报文段中出现，接收通告窗口大小用16位表示，即最大65535字节，但实际上TCP模块允许的窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题，若TCP头部的接收通告窗口大小为N，窗口扩大因子为M，则TCP报文段的实际接收通告窗口大小为（N&lt;&lt;M），M取值范围为0~14。<strong>{</strong>可以通过修改<code>/proc/sys/net/ipv4/tcp_window_scaling</code>内核变量来启用或者关闭窗口扩大因子选项<strong>}</strong></p>
<p><strong>注意</strong>，同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。</p>
<p>kind=4是<strong>选择性确认</strong>（Selective Acknowledgment, SACK）选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，不过这样原来已经正确传输的TCP报文段也可能重复发送，从而降低了TCP的性能。SACK技术解决了这个问题，它使TCP模块只重新发送丢失的TCP报文段。<strong>{</strong>可以通过修改<code>/proc/sys/net/ipv4/tcp_sack</code>内核变量来启用或者关闭选择性确认选项<strong>}</strong></p>
<p>kind=5是<strong>SACK实际工作</strong>的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。</p>
<p>kind=8是<strong>时间戳选项</strong>。该选项提供了较为精准的计算通信双方之间的回路时间（Round Trip Time, RTT）的方法，从而为TCP流量控制提供重要信息。<strong>{</strong>可以通过修改<code>/proc/sys/net/ipv4/tcp_timestamps</code>内核变量来启用或者关闭时间戳选项<strong>}</strong></p>
<h4 id="使用tcpdump观察TCP头部信息"><a href="#使用tcpdump观察TCP头部信息" class="headerlink" title="使用tcpdump观察TCP头部信息"></a>使用tcpdump观察TCP头部信息</h4><p>在上一章使用<code>tcpdump</code>进行抓包，分析了IPv4的头部，这里继续看这个数据包中的TCP头部信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IP 127.0.0.1.46024 &gt; 127.0.0.1.23: Flags [S], seq 2327807816, win 32792, options [mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6], length 0</span><br><span class="line">	0x0000:  4510 003c 0995 4000 4006 3315 7f00 0001</span><br><span class="line">	0x0010:  7f00 0001 b3c8 0017 8abf 8748 0000 0000</span><br><span class="line">	0x0020:  a002 8018 fe30 0000 0204 400c 0402 080a</span><br><span class="line">	0x0030:  026e 44d9 0000 0000 0103 0306</span><br></pre></td></tr></table></figure>

<p>Flags [S]，表示该TCP报文段包含SYN标志，因此是一个同步报文段。</p>
<p>seq是序号值，因为是从<code>127.0.0.1.46024</code>到<code>127.0.0.1.23</code>的第一个报文段，该序号值就是此次通信过程中<strong>该传输方向</strong>的ISN值。并且，因为是整个传输过程中的第一个报文段，它并没有针对对方报文段的确认值。</p>
<p>win是接收通告窗口的大小。因为是同步报文段，所以win值反映的是该报文段的实际接收通告窗口大小。</p>
<p>options是TCP选项，具体内容在方括号中。<code>mss</code>是发送端通告的最大报文段长度，通过<code>ifconfig</code>命令查看回路接口的MTU为16436字节，因此可以预想MSS为（16436-40，即16396字节）；<code>sackOK</code>表示发送端支持并同意使用SACK选项；<code>TS val</code>是发送端的时间戳；<code>ecr</code>是时间戳的回显应答。因为是第一个报文段，所以它针对对方的时间戳的应答为0（表示未收到对方的时间戳）；<code>nop</code>是一个空操作选项；<code>wscale</code>指出发送端使用的窗口扩大因子为6。</p>
<p>接下来分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始。</p>
<table>
<thead>
<tr>
<th>十六进制数</th>
<th>十进制/二进制表示</th>
<th>TCP头部信息</th>
</tr>
</thead>
<tbody><tr>
<td>0xb3c8</td>
<td>46024</td>
<td>源端口号</td>
</tr>
<tr>
<td>0x0017</td>
<td>23</td>
<td>目的端口号</td>
</tr>
<tr>
<td>0x8abf 8748</td>
<td>2327807816</td>
<td>序列号</td>
</tr>
<tr>
<td>0x0000 0000</td>
<td>0</td>
<td>确认号</td>
</tr>
<tr>
<td>0xa</td>
<td>10</td>
<td>TCP头部长度为10个32bit（40字节）</td>
</tr>
<tr>
<td>0x002</td>
<td>‘0000 0000 0010</td>
<td>前六位保留，标志位设置了SYN</td>
</tr>
<tr>
<td>0x8018</td>
<td>32792</td>
<td>接受通告窗口大小</td>
</tr>
<tr>
<td>0xfe30</td>
<td></td>
<td>校验和（此时没有数据，就只有头部）</td>
</tr>
<tr>
<td>0x0000</td>
<td></td>
<td>没有设置紧急指针</td>
</tr>
<tr>
<td>0x0204</td>
<td></td>
<td>最大报文段长度选项的kind和length值</td>
</tr>
<tr>
<td>0x400c</td>
<td>16396</td>
<td>最大报文段长度【4-2得到2字节表示该值】</td>
</tr>
<tr>
<td>0x0402</td>
<td></td>
<td>允许SACK选项</td>
</tr>
<tr>
<td>0x080a</td>
<td></td>
<td>时间戳选项的kind和length值</td>
</tr>
<tr>
<td>0x026e 44d9</td>
<td>40781017</td>
<td>时间戳</td>
</tr>
<tr>
<td>0x0000 0000</td>
<td>0</td>
<td>回显应答时间戳</td>
</tr>
<tr>
<td>0x01</td>
<td></td>
<td>空操作</td>
</tr>
<tr>
<td>0x0303</td>
<td></td>
<td>窗口扩大因子选项的kind和length值</td>
</tr>
<tr>
<td>0x06</td>
<td>6</td>
<td>窗口扩大因子为6</td>
</tr>
</tbody></table>
<h3 id="TCP连接的建立和关闭"><a href="#TCP连接的建立和关闭" class="headerlink" title="TCP连接的建立和关闭"></a>TCP连接的建立和关闭</h3><p>三次握手，四次挥手的过程：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/14/VZhsYjq8eLk9l5Q.jpg" alt="TCP的建立与关闭.jpg"></p>
<p><strong>连接建立（三次握手）</strong>：</p>
<p>第一个报文段包含SYN标志，是一个同步报文段，即<code>ernest-laptop</code>向<code>Kongming20</code>发起连接请求。该报文段中包含一个ISN值为535734930的序号。</p>
<p>第二个报文段也是一个同步报文段，表示<code>Kongming20</code>同意与<code>ernest-laptop</code>建立连接。同时发送自己ISN值为2159701207的序号，并对第一个报文段进行确认。</p>
<p>第三个报文段对第二个报文段进行确认。至此，TCP连接建立。</p>
<blockquote>
<p>注意，从第三个报文段之后，tcpdump输出的序号值和确认值都是相对于初始ISN值的偏移（图中不是偏移），也可以用tcpdump的-S选项来打印序号的绝对值。</p>
</blockquote>
<p><strong>连接关闭（四次挥手）</strong>：</p>
<p>第四个报文段包含FIN标志，因此它是一个结束报文段，即<code>ernest-laptop</code>要求关闭连接。</p>
<p><code>Kongming20</code>用TCP报文段5来确认对方的结束报文段。（可省略，因为6也包含了确认信息）</p>
<p><code>Kongming20</code>发送自己的结束报文段6。</p>
<p><code>ernest-laptop</code>用TCP报文段7来予以确认。</p>
<p>在这里，是ernest-laptop先发送结束报文段，故称ernets-laptop执行主动关闭，而Kongming20执行被动关闭。</p>
<h4 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h4><p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。</p>
<p>也就是说，通信的一方可以发送<code>结束报文段</code>给对方，表明自己本端已经完成了数据的发送，但是却允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。这种状态称为半关闭状态，如下图所示。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/14/NbJcZ4KaghfIvAH.jpg" alt="TCP半关闭状态.jpg"></p>
<p>注意，图中服务器和客户端应用程序判断<strong>对方</strong>是否已经关闭连接的方法是：read系统调用返回0（即收到结束报文段）。</p>
<p>socket网络编程接口通过shutdown函数提供了对半关闭的支持。</p>
<p>虽然介绍了半关闭状态，但是使用半关闭的应用程序很少见。</p>
<h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p>如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢？</p>
<p>对于提供可靠服务的TCP来说，必然是先进行重连（可能执行多次），如果重连仍无效，则通知应用程序连接超时。可以使用iptable来过滤数据报，丢弃同步报文段来模拟实验。</p>
<p>实验过程略（见书P40）。</p>
<h3 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h3><p>TCP链接的任意一端在任一时刻都处于某种状态，当前状态可以通过<code>netstat</code>命令查看。</p>
<p>下面是完整的状态转移图：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/08/08189b39d6064425.webp" alt="TCP状态转移图"></p>
<p>粗虚线表示服务器端的状态连接；粗实线表示客户端的状态连接。CLOSED是一个假想的起始点，并不是一个实际的状态。</p>
<h4 id="TCP状态转移总图"><a href="#TCP状态转移总图" class="headerlink" title="TCP状态转移总图"></a>TCP状态转移总图</h4><p>先来看<strong>服务器</strong>的典型状态转移过程。</p>
<p>服务器通过listen系统调用进入<code>LISTEN</code>状态，被动等待客户端连接（即，被动打开）。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于<code>SYN_RCVD</code>状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到<code>ESTABLISHED</code>状态。</p>
<p>当客户端主动关闭连接时（通过close或shutdown系统调用，向服务器发送结束报文段），服务器通过返回确认报文段使连接进入<code>CLOSE_WAIT</code>状态。等待服务器应用程序关闭连接。待服务器向客户端发送结束报文段，就使得连接进入<code>LAST_ACK</code>状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。</p>
<p>下面讨论<strong>客户端</strong>的典型状态转移过程。</p>
<p>客户端通过connect系统调用（向服务器发送一个同步报文段）主动与服务器建立连接，使连接转移到<code>SYN_SENT</code>状态。不过，connect系统调用可能因为如下两个原因而失败：</p>
<ol>
<li>connect连接的<strong>目标端口不存在</strong>（未被服务器任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用（见后文），则服务器将给客户端发送一个复位报文段，connect调用失败；</li>
<li>若端口存在，但connect在<strong>超时</strong>时间内未收到服务器的确认报文段，则connect调用失败。</li>
</ol>
<p>connect调用失败将使连接立即返回设想的<code>CLOSED</code>状态。若客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至<code>ESTABLISHED</code>状态。</p>
<p>客户端执行主动关闭时，将向服务器发送一个结束报文段，同时进入<code>FIN_WAIT_1</code>状态。若收到服务器的确认报文段，连接就能转移到<code>FIN_WAIT_2</code>状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接，则客户端将给予确认并进入<code>TIME_WAIT</code>状态。</p>
<p>图中还描绘了其他非典型的TCP状态转移路线，比如同时关闭与同时打开，不作讨论。</p>
<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>上面说了，客户端在收到服务器结束报文段之后，并没有直接进入CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，<strong>客户端连接要等待一段2MSL</strong>（Maximum Segment Life，报文段最大生存时间）<strong>的时间</strong>，才能完全关闭，对于MSL，RFC 1122的建议值是2min。</p>
<p>TIME_WAIT状态存在的原因有两点：</p>
<ol>
<li><p>可靠地终止TCP连接</p>
<p>假设用于确认服务器结束报文段的确认报文丢失，那么服务器讲重发结束报文段。因此客户端需要停留在一个状态来处理重复收到的结束报文段。否则，客户端将以复位报文段回应服务器，服务器则认为这是一个错误，因为它期望的是一个确认报文段。</p>
</li>
<li><p>保证让迟到的TCP报文段有足够的时间被识别并丢弃</p>
<p>一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时，将无法立即使用该连接占用的端口来建立一个新连接。反过来思考，如果不存在TIME_WAIT状态，则可以立即建立一个与刚才连接有相同IP以及端口号的连接，这样的新连接可能收到原来连接迟到的报文段，而这显然是不应该发生的。</p>
</li>
</ol>
<h3 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h3><p>在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。这里讨论复位报文段的3种情况。</p>
<h4 id="访问不存在的端口"><a href="#访问不存在的端口" class="headerlink" title="访问不存在的端口"></a>访问不存在的端口</h4><p>当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。</p>
<p>其实，当服务器某个端口仍被处于<code>TIME_WAIT</code>状态的连接所占用时，客户端程序也将收到复位报文段。</p>
<h4 id="异常终止连接"><a href="#异常终止连接" class="headerlink" title="异常终止连接"></a>异常终止连接</h4><p>之前讨论的都是正常的终止方式，即：数据交换完成之后，一方给另一方发送结束报文段。</p>
<p>TCP提供了异常终止一个连接的方法，给对方发送一个复位报文段。一旦发送该复位报文段，发送端所有排队等待发送的数据都将被丢弃。</p>
<p>应用程序可以适用socket选项<code>SO_LINGER</code>来发送复位报文段，以异常终止一个连接。</p>
<h4 id="处理半打开连接"><a href="#处理半打开连接" class="headerlink" title="处理半打开连接"></a>处理半打开连接</h4><p>假设服务器与客户端的某一方为A，另一方为B。</p>
<blockquote>
<p>A关闭或者异常终止了连接，而对方没有接收到结束报文段，此时，B仍然维持着原来的连接，A即使重启也没有该连接的任何信息了。这种状态称为<strong>半打开状态</strong>。</p>
</blockquote>
<p>若B往处于半打开状态的连接写入数据，则A将回应一个复位报文段。</p>
<h3 id="TCP的数据流"><a href="#TCP的数据流" class="headerlink" title="TCP的数据流"></a>TCP的数据流</h3><p>TCP报文段所携带的应用程序数据按照长度分为两种：<code>交互数据</code> 和 <code>成块数据</code>。</p>
<p><code>交互数据</code>仅包含很少的字节。使用交互数据的应用程序（或协议）对<strong>实时性</strong>要求高，比如telnet、ssh等。</p>
<p><code>成块数据</code>其长度通常为TCP报文段允许的最大数据长度（即MSS）。使用成块数据的应用程序（或协议）对<strong>传输效率</strong>要求高，比如ftp。</p>
<p>在这一节，先讨论交互数据流。</p>
<h4 id="TCP交互数据流"><a href="#TCP交互数据流" class="headerlink" title="TCP交互数据流"></a>TCP交互数据流</h4><p>通常是一些携带ACK标志的报文段。携带交互数据的微小TCP报文段数量一般很多（一个按键输入就导致一个TCP报文段，见47页例子）。</p>
<p>服务器的<strong>延迟确认</strong>：即服务器不马上确认上次收到的数据，而是在一端延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段时总是有数据一起发送。<u>这样可以减少发送TCP报文段的数量</u>。</p>
<p>交互数据流在广域网上可能存在很大的延迟，导致拥塞发生。解决的一个简单有效的方法是使用<code>Nagle</code>算法。</p>
<blockquote>
<p><code>Nagle</code>算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段，在该TCP报文段的确认到达之前不能发送其他TCP报文段。 另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。</p>
</blockquote>
<p>这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越快。</p>
<h4 id="TCP成块数据流"><a href="#TCP成块数据流" class="headerlink" title="TCP成块数据流"></a>TCP成块数据流</h4><p>考虑用FTP协议传输一个大文件。发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。</p>
<p>而发送方在收到上一次确认之后，还能继续发送多少个报文段呢？</p>
<p>这是由接收通告窗口（还需要考虑拥塞窗口）的大小决定的。如，报文段中win为30084，窗口扩大因子为6，则表示客户端还能接收30084*64字节，按每个报文段长度16384字节来算，发送方还能继续发送的报文段数量为 30084*64/16384即106个。</p>
<h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><p>有些传输层协议具有<code>带外（Out of Band, OOB）数据</code>的概念。用于迅速通告对方本端发生的重要事件。</p>
<p>带外数据的传输有两种方式：</p>
<ol>
<li>使用一条独立的传输层连接</li>
<li>映射到传输普通数据的连接中</li>
</ol>
<p>因此，<strong>带外数据比普通数据（也称带内数据）有更高的优先级，它应该立即被发送</strong>，而不论发送缓冲区中是否有派对等待发送的普通数据。不过，实际应用中，带外数据的使用很少见。</p>
<p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过，TCP利用其头部的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式，该方式利用传输普通数据的连接来传输带外数据。这种紧急数据的含义和带外数据类似（因此后文将TCP紧急数据称为带外数据）。</p>
<p>当TCP向连接中发送带外数据时，会将含带外数据的报文段头部设置<code>URG</code>标志，并且紧急指针被设置为指向最后一个带外数据的下一字节（多字节的带外数据中只有最后一个字节被当作带外数据，因为<strong>接收端的带外缓冲只有1个字节</strong>，并且上层应用没有及时将带外数据从带外缓存中读出，后续的带外数据将覆盖它）。</p>
<h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>在剩下的两节中，讨论异常网络状况下（开始出现超时或丢包），TCP如果控制数据传输以保证其承诺的可靠服务。</p>
<p>对于超时，<strong>TCP模块为每个TCP报文段维护一个重传定时器</strong>，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的确认应答，TCP模块将重传TCP报文段并重置定时器。</p>
<p>至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。</p>
<blockquote>
<p>Linux下TCP的超时重传策略为：每次重传后，超时时间都增加一倍。</p>
</blockquote>
<p>在所有重传均失败的情况下，底层的IP和ARP开始接管，直到客户端放弃连接为止。</p>
<p>Linux中有两个重要的内核参数与TCP超时重传相关：</p>
<p><code>/proc/sys/net/ipv4/tcp_retries1</code>：指定底层IP接管之前TCP<strong>最少</strong>执行的重传次数，默认值是3。</p>
<p>``/proc/sys/net/ipv4/tcp_retries2`：指连接放弃前TCP<strong>最多</strong>可以执行的重传次数，默认值是15。</p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，在下一节讨论。</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的<code>拥塞控制</code>（详见RFC 5681）。</p>
<p>拥塞控制包括四个部分：</p>
<ul>
<li>慢启动（slow start）</li>
<li>拥塞避免（congestion avoidance）</li>
<li>快速重传（fast retransmit）</li>
<li>快速恢复（fast recovery）</li>
</ul>
<p>Linux下对拥塞算法有多种实现，如reno算法，vegas算法和cubic算法等。它们或部分或全部实现了上述的四个部分。<code>/proc/sys/net/ipv4/tcp_congestion_control</code>文件指示了机器当前所使用的拥塞控制算法。</p>
<blockquote>
<p>拥塞控制的最终受控变量是<code>发送窗口（Send Window，SWND）</code>，即发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量或TCP报文段数量。</p>
</blockquote>
<p>这些TCP报文段的最大长度（仅指数据部分）称为SMSS（Sender MSS，发送者最大段大小），其值一般等于MSS。</p>
<p>发送端需要合理地选择<code>SWND</code>的大小。若<code>SWND</code>太小，会引起明显的网络延迟；反之，如果<code>SWND</code>太大，则容易导致网络拥塞。前文提到，在TCP头部中的<code>接收通告窗口（RWND）</code>可以控制发送端的传输速度，同时，发送端也引入了一个称为<code>拥塞窗口（Congestion Window, CWND）</code>的状态变量来控制<code>SWND</code>。实际的<code>SWND</code>值是RWND和CWND中的较小者。</p>
<h4 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h4><p>TCP连接建立好之后，CWND将被设置成初始值IW（Initial Window），其大小为2~4个SMSS。但新的Linux内核提高了该初始值，以减小传输延迟。此后，发送端每收到接收端的一个确认，其CWND就按下面公式增加：<br>$$<br>CWND+=min(N,SMSS)  【3.1】<br>$$<br>其中，N是此次确认中包含的之前未被确认的字节数。</p>
<p>这样，CWND将按照指数形式扩大，这就是所谓的<code>慢启动</code>。其理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试探的方式平滑地增加CWND的大小。</p>
<p>但如果不施加其他手段，慢启动必然使CWND很快膨胀（可见慢启动其实不慢），并最终导致网络拥塞。因此，TCP拥塞控制中定义了一个重要的状态变量：慢启动门限（slow start threshold size, ssthresh）。当CWND大小超过该值时，TCP拥塞控制将进入<code>拥塞避免阶段</code>。</p>
<p>拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。RFC 5681中提到两种实现方式：</p>
<ol>
<li><p>每个RTT时间内按照公式3.1计算新的CWND，而不管该RTT时间内发送端收到多少个确认。</p>
</li>
<li><p>每收到一个对新数据的确认报文段，就按照公式3.2来更新CWND。<br>$$<br>CWND+=SMSS*SMSS/CWND【3.2】<br>$$</p>
</li>
</ol>
<p>以上，讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍<strong>拥塞发生时</strong>拥塞控制的行为。不过，首先需要弄明白发送端如何判断拥塞已经发生。发送端判断依据有如下两个：</p>
<ul>
<li>传输超时，或者说TCP重传定时器溢出</li>
<li>接收到重复的确认报文段</li>
</ul>
<p>第一种情况仍使用慢启动和拥塞避免。将进行重传，并做如下调整：<br>$$<br>ssthresh=max(FlightSize/2,2*SMSS)【3.3】<br>$$</p>
<p>$$<br>CWND&lt;=SMSS<br>$$</p>
<p>其中FlightSize是已经发送但未收到确认的字节数。这样调整之后，CWND将小于SMSS，也必然小于新的慢启动门限值ssthresh。</p>
<p>对第二中情况则使用快速重传和快速恢复。</p>
<h4 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h4><p>很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排等。</p>
<p>拥塞控制算法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞。具体做法是：<strong>发送端如果连续收到3个重复的确认报文段，就认为是拥塞发生了</strong>。然后使用快速重传和快速恢复算法来处理拥塞，具体过程如下：</p>
<ol>
<li><p>当收到第三个重复的确认报文段时，按公式3.3计算<code>ssthresh</code>，然后立即重传丢失的报文段，并按照公式3.4设置CWND。<br>$$<br>CWND=ssthresh+3*SMSS【3.4】<br>$$</p>
</li>
<li><p>每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段。</p>
</li>
<li><p>当收到新数据的确认时，设置CWND=ssthresh。</p>
</li>
</ol>
<p>快速重传和快速恢复完成之后，拥塞控制将恢复到拥塞避免阶段。</p>
<h2 id="TCP-IP通信案例：访问Internet上的Web服务器"><a href="#TCP-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="TCP/IP通信案例：访问Internet上的Web服务器"></a>TCP/IP通信案例：访问Internet上的Web服务器</h2><p>由于本章内容叙述上不方便，就不全放到博客中了，挑一些关键的知识点来说。</p>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>在HTTP通信链上，客户端和目标服务器之间通常存在某种中转代理服务器，他们提供对目标资源的中转访问。代理服务器按照其使用方式和作用，分为正向代理服务器、反向代理服务器和透明代理服务器。</p>
<ul>
<li>正向代理：要求客户端自己设置代理服务器的地址。客户的每次请求都将直接发送到该服务器，并由代理服务器来请求目标资源。</li>
<li>反向代理：被设置在服务器端，客户端无需进行任何设置。代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。</li>
<li>透明代理只能设置在网关上。透明代理可以看成正向代理的一种特殊情况。</li>
</ul>
<p>代理服务器通常还提供缓存目标资源的功能。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而varnish仅能用作反向代理。</p>
<p>可以用<code>service</code>脚本程序启动服务器程序，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service squid3 restart</span><br></pre></td></tr></table></figure>

<p><code>service</code>是一个脚本程序（/usr/sbin/service），它为 /etc/init.d 目录下的众多服务器程序（如httpd、vsftpd、sshd和mysqld等）的启动（start）、停止（stop）和重启（restart）等动作提供了统一的管理。</p>
<h3 id="本地名称查询"><a href="#本地名称查询" class="headerlink" title="本地名称查询"></a>本地名称查询</h3><p>一般来说，通过域名访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问<strong>本地局域</strong>网上的机器，则可以通过<code>本地静态文件</code>来获得该机器的IP地址。</p>
<p>Linux将目标主机名及其对应IP地址存储在/etc/hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，将求助于DNS服务。</p>
<h1 id="深入解析高性能服务器编程"><a href="#深入解析高性能服务器编程" class="headerlink" title="深入解析高性能服务器编程"></a>深入解析高性能服务器编程</h1><h2 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h2><p>本章是承前启后的一章，从三个方面讨论Linux网络API:</p>
<ul>
<li>socket地址API。socket最开始的含义是一个IP地址和端口对（ip, port）。它唯一地表示了使用TCP通信的一端。</li>
<li>socket基础API。socket的主要API都定义在<code>sys/socket.h</code>头文件中，包括创建、命名、监听、接收连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</li>
<li>网络信息API。Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中。</li>
</ul>
<p>所谓socket（套接字），就是对网络中<strong>不同主机上的应用程序之间进行双向通信的端点</strong>的抽象。一个socket就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。socket上联应用程序，下联网络协议栈，是应用程序通过网络协议进行通信的接口。</p>
<h3 id="socket地址API"><a href="#socket地址API" class="headerlink" title="socket地址API"></a>socket地址API</h3><p>要学习socket地址API，要先理解<code>主机字节序</code>和<code>网络字节序</code>。</p>
<h4 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h4><blockquote>
<p>字节序，是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。</p>
</blockquote>
<p>字节序分为小端字节序（little endian）和大端字节序（big endian）。</p>
<p><strong>小端字节序</strong>：<strong>将低位字节存储在低地址处</strong>。</p>
<p><strong>大端字节序</strong>：<strong>将高位字节存储在低地址处</strong>。</p>
<p>比如，内存中的两个字0x01020304的存储方式（&amp;4000~$40003是地址单元）：</p>
<table>
<thead>
<tr>
<th></th>
<th>&amp;4000</th>
<th>&amp;4001</th>
<th>&amp;4002</th>
<th>&amp;4003</th>
</tr>
</thead>
<tbody><tr>
<td>小端字节序</td>
<td>04</td>
<td>03</td>
<td>02</td>
<td>01</td>
</tr>
<tr>
<td>大端字节序</td>
<td>01</td>
<td>02</td>
<td>03</td>
<td>04</td>
</tr>
</tbody></table>
<p>下面的代码可以检查机器的字节序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        short value;</span><br><span class="line">        <span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(short)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unknown...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现代PC大多采用小端字节序，因此<strong>小端字节序又被称为主机字节序</strong>。</p>
<p>现在我们来假设，数据在两台使用不同字节序的主机之间进行传输，可想而知，接收端必然会错误地解释数据。而解决的方法是：<strong>协商一个在网络中传输时使用的字节序</strong>。这样，接收端知道对方传过来的总是特定字节序的数据，而再根据自身采用的字节序来决定是否需要进行转换（不同则转，相同不转）。我们将大端字节序协商为网络传输中使用的字节序，因此，<strong>大端字节序也称为网络字节序</strong>。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如”htonl”表示“host to network long”。<u>长整型函数通常用来转换IP地址，短整型函数通常用来转换端口号</u>。</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><p>socket网络编程接口中表示socket地址的是结构体<code>sockaddr</code>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><em>sa_family</em></strong>是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP/IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP/IPv6协议族</td>
</tr>
</tbody></table>
<p>宏PF_*和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p><strong><em>sa_data</em></strong>用于存放socket地址值。但是，不同的协议族的地址值具有<u>不同的含义和长度</u>，如下表所示：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16bit端口号，32bit流表示，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody></table>
<p>由表可见，14字节的<code>sa_data</code>根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个<strong>新的</strong>通用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>上面两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行繁琐的位操作。因此，Linux为各个协议族提供了专门的socket地址结构体。</p>
<p><strong>UNIX本地域协议</strong>使用的专用socket地址结构体：<code>sockaddr_un</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;        <span class="comment">/* 地址族：AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];            <span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TCP/IP协议族有<code>sockadrr_in</code>和<code>sockaddr_in6</code>两个专用socket地址结构体，分别于IPv4和IPv6：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sockaddr_in 在#include&lt;netinet/in.h&gt;或#include&lt;arpa/inet.h&gt;中定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;         <span class="comment">/* 地址族：AF_INET */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;             <span class="comment">/* 端口号，用网络字节序表示 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>        <span class="comment">/* IPv4地址结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;               <span class="comment">/* IPv4地址，用网络字节序表示 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;        <span class="comment">/* 地址族：AF_INET6 */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;            <span class="comment">/* 端口号，用网络字节序表示 */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_flowinfo;        <span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>      <span class="comment">/* IPv6地址结构体 */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_scope_id;        <span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];      <span class="comment">/* IPv6地址，用网络字节序表示 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要特别注意：</p>
<blockquote>
<p>所有<strong>专用socket地址</strong>（以及sockaddr_storage）类型的变量在实际使用时都需要<strong>转化为通用socket地址类型sockaddr</strong>（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p>
</blockquote>
<h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>通常，我们习惯用字符串来表示IP地址，如点分十进制表示IPv4地址，十六进制表示IPv6地址。但在编程中，需要将它们转化为整数才能使用，而记录日志时，却又要转化为可读的字符串。下面，提供了3个函数用于 <strong>点分十进制字符串表示的IPv4地址</strong> 和 <strong>用网络字节序整数表示的IPv4地址</strong> 之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_adrr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>in_addr_t</code>函数将点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败将返回INADDR_NONE。</p>
<p><code>inet_aton</code>函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功返回1，失败返回0。</p>
<p><code>inet_ntoa</code>函数将用网络字节序整数表示的IPv4地址转化为用淀粉十进制字符串表示的IPv4地址。但是，<strong>需要注意</strong>，<strong>该函数内部用一个<u>静态变量</u>存储转化结果</strong>，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。下面代码揭示了其不可重入性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* szValue1 = inet_ntoa(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”);</span><br><span class="line"><span class="keyword">char</span>* szValue2 = inet_ntoa(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address1: %s\n"</span>,szValue1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address2: %s\n"</span>,szValue2);</span><br></pre></td></tr></table></figure>

<p>得到的结果是，address1和address2都是10.194.71.60。</p>
<p>下面还有一对函数也能完成和前面3个函数同样的功能，并且还同时适用于IPv4和IPv6地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>* dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>af</code>用于指定地址族，可以是AF_INET或者是AF_INET6。inet_pton成功返回1，失败返回0并设置errno。</p>
<p>inet_ntop进行相反的转换，其中最后一个参数<code>cnt</code>指定目标存储单元的大小。成功返回目标存储单元的地址，失败返回NULL并设置errno。下面两个宏能帮助我们指定这个大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16          <span class="comment">/* 用于IPv4 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46         <span class="comment">/* 用于IPv6 */</span></span></span><br></pre></td></tr></table></figure>



<h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><p><code>socket</code>就是可读、可写、可控制、可关闭的<strong>文件描述符</strong>。下面的系统调用可以创建一个socket:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>domain</em></strong>参数告诉系统应该适用哪个底层协议族（PF_INET，PF_INET6或PF_UNIX等）。</p>
<p><strong><em>type</em></strong>参数指定服务类型。服务类型主要有<code>SOCK_STREAM</code>（流服务，表示传输层用TCP协议）以及<code>SOCK_DGRAM</code>（数据报服务，表示传输层用UDP协议）。</p>
<blockquote>
<p>值得注意，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要标志相与的值：SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示，将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。</p>
</blockquote>
<p><strong><em>protocol</em></strong>参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常是唯一的（前两个参数已经完全决定了它）。<strong>几乎在所有情况下，都将它设置为0</strong>，表示使用默认协议。</p>
<p>socket系统调用成功时返回一个<code>socket文件描述符</code>，失败则返回<code>-1</code>并设置errno。</p>
<h3 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h3><p>创建socket时，指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。<strong>将一个<code>socket</code>与<code>socket地址</code>绑定称为给socket命名</strong>。</p>
<p>服务器程序中，通常要命名socket，只有这样客户端才知道该如何连接它。客户端则不需要命名socket，而是采用匿名的方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是<strong><code>bind</code></strong>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>bind</code>将<strong><em>my_addr</em></strong>所指的socket地址分配给未命名的<strong><em>sockfd</em></strong>文件描述符，<strong><em>addrlen</em></strong>参数指定该socket地址的长度。bind成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。其中常见的两种errno含义如下：</p>
<ul>
<li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。如普通用户将socket绑定到知名服务端口（端口号为0~1023）上时。</li>
<li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</li>
</ul>
<h3 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h3><p>socket被命名之后，还不能马上接受客户连接，需要使用如下的系统调用来<u>创建一个监听队列，以存放待处理的客户连接</u>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数指定被监听的socket。</p>
<p><strong><em>backlog</em></strong>参数指定内核监听队列的最大长度。典型值是5，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<blockquote>
<p>自linux内核2.2之后，backlog参数表示只处于完全连接状态（ESTABLISHED）socket的上限。</p>
<p>监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。</p>
</blockquote>
<p><code>listen</code>调用成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。</p>
<p>下面编写一个服务器程序，以研究backlog参数对listen系统调用的实际影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="built_in">stop</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stop</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGTERM, handle_term);     <span class="comment">// 信号处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number backlog\n"</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> backlog = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// create a socket</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an address of IPv4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));      <span class="comment">// 置零，类似于memset，但是更好记</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, backlog);</span><br><span class="line">    assert( ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop, wait to connect, until stop turn to true</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stop</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于signal函数的用法，可参考：<a href="https://www.runoob.com/cprogramming/c-function-signal.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-signal.html</a></p>
</blockquote>
<p>我通过<code>vmware</code>建立了两台处于同一局域网的ubuntu主机，一台作为服务器（192.168.141.137），另一台作为客户端（192.168.141.139）。以此来作为测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器编译运行代码</span></span><br><span class="line">$ gcc testlisten.c -o testlisten</span><br><span class="line">$ ./testlisten 192.168.141.137 12345 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端开多个命令窗口执行，以建立多个连接</span></span><br><span class="line">$ telnet 192.168.141.137 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器执行netstat，以查看连接状况</span></span><br><span class="line">$ netstat -nt | grep 12345</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/6b377c6936297bd1.webp" alt=""></p>
<p>这里的截图显示已经运行成功了，而监听队列最多就存在6（backlog+1）个ESTABLISHED状态的连接。</p>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><p><code>accept</code>系统调用能够从listen监听队列中接受一个连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数是<u>执行过listen系统调用的监听socket</u>。</p>
<p><strong><em>addr</em></strong>参数用来获取<code>被接受连接</code>的远端socket地址（创建一个空的结构体，由accetp函数进行填充），该socket地址的长度由<strong><em>addrlen</em></strong>参数指出。（addrlen在调用时设置为addr指向区域的大小，而调用结束时被设置为实际地址信息的长度，在函数调用过程中需要改变，所以要指针）</p>
<p><code>accept</code>调用成功时返回一个<code>新的连接socket</code>，该socket唯一地标识了被接受的这个连接，<strong>服务器可通过读写该socket来与连接对应的客户端通信</strong>。失败则返回<code>-1</code>并设置errno。</p>
<p>我们编写如下代码，并考虑处于ESTABLISHED连接的客户端出现网络异常，或者提前退出时，服务器的accept调用是否成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:%s ip_address port_number\n"</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock,<span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait 20 sec, client incomes network failure</span></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is: %d\n"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept seccess</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connceted with ip: %s and port: %d\n"</span>, inet_ntop(AF_INET,</span><br><span class="line">            &amp;client.sin_addr,remote,INET_ADDRSTRLEN),ntohs(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我将在网络中【服务器IP：192.168.141.137，客户端IP：192.168.141.139】进行测试该代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器中编译运行程序</span></span><br><span class="line">$ gcc testaccept.c -o testaccept</span><br><span class="line">$ ./testaccept 192.168.141.137 54321</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动客户端telnet程序，并立即（要在20s内）断开网络连接</span></span><br><span class="line">$ telnet 192.168.141.137 54321</span><br><span class="line"><span class="comment"># 断开网卡，我这里网卡叫eth0，不同主机网卡名可能不同</span></span><br><span class="line">$ ifconfig etho down</span><br></pre></td></tr></table></figure>

<p>得到的测试结果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/726f8cd23f78e233.webp" alt=""></p>
<p>可以发现<code>accept</code>调用能够正常返回，并输出客户端的IP与连接端口号。由此可见，<strong>accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化</strong>。</p>
<p>同时，该程序结束后，我们马上重新执行程序会出错，使用netstat查看网络状况，可以看到刚刚的连接处于<code>TIME_WAIT</code>状态。这是TCP连接刚断开后进入的状态，等待2*MSL的时间，就恢复正常了。</p>
<h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><p>服务器通过<code>listen</code>调用来<strong>被动</strong>接受连接，而客户端需要通过如下系统调用来<strong>主动</strong>与服务器建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数是由客户端socket系统调用返回的一个socket。</p>
<p><strong><em>serv_addr</em></strong>参数是服务器监听的socket地址，<strong><em>addrlen</em></strong>参数则指定这个地址的长度。</p>
<p><code>connect</code>成功时返回<code>0</code>。一旦成功建立连接，sockfd就唯一标识了这个连接，<strong>客户端就可以通过读写sockfd来与服务器通信</strong>。失败则返回<code>-1</code>并设置errno。常见的两种errno含义如下：</p>
<ul>
<li>ECONNREFUSED，目标端口不存在，连接被拒绝。</li>
<li>ETIMEDOUT，连接超时。</li>
</ul>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭一个连接实际上就是关闭该连接对应的socket，可以通过关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>fd</em></strong>参数是待关闭的socket。</p>
<p>不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减<code>1</code>。<strong>只有当fd的引用计数为<code>0</code>时，才真正关闭连接</strong>。在多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p>
<p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用<code>shutdown</code>系统调用（相对于close来说，它是专门为网络编程设计的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数是待关闭的socket。</p>
<p><strong><em>howto</em></strong>参数决定了shutdown的行为，可以取下表中的某个值：</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHUT_RD</td>
<td>关闭sockfd上读的一半。应用程序不能再针对socket文件描述符执行读操作，并且该socket<code>接收缓冲区</code>中的数据都将被丢弃。</td>
</tr>
<tr>
<td>SHUT_WR</td>
<td>关闭sockfd上写的一半。sockfd的<code>发送缓冲区</code>中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socket文件描述符执行写操作。这种情况下，处于半关闭状态。</td>
</tr>
<tr>
<td>SHUT_RDWR</td>
<td>同时关闭sockfd上的读和写</td>
</tr>
</tbody></table>
<p>由此可见，<code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。而<code>close</code>再关闭连接时只能将读写都关闭。</p>
<p><code>shutdown</code>调用成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。</p>
<h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><h4 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h4><p>对文件的读写操作（read和write）同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于<strong>TCP流数据</strong>读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>recv</code>读取<strong><em>sockfd</em></strong>上的数据，<strong><em>buf</em></strong>和<strong><em>len</em></strong>参数分别指定<strong>读缓冲区</strong>的位置和大小，<strong><em>flags</em></strong>参数的含义见后文，通常设置为0即可。 <code>recv</code>调用成功时返回<strong>实际读取到的数据的长度</strong>，它可能小于我们期望的长度（len）。因此可能要多次调用recv，才能读取到完整的数据。 【注意，<code>recv</code>可能返回0，这意味着通信对方已经关闭连接了】。<code>recv</code>出错时返回<code>-1</code>并设置errno。</p>
<p><code>send</code>往<strong><em>sockfd</em></strong>上写入数据，<strong><em>buf</em></strong>和<strong><em>len</em></strong>参数分别指定<strong>写缓冲区</strong>的位置和大小。<code>send</code>成功时返回<strong>实际写入的数据的长度</strong>，失败则返回<code>-1</code>并设置errno。</p>
<p><strong><em>flags</em></strong>参数为数据收发提供了额外的控制，它可以取下表选项中的一个或者多个的<strong>逻辑或</strong>。</p>
<table>
<thead>
<tr>
<th>选项名</th>
<th>含义</th>
<th>send</th>
<th>recv</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_CONFIRM</td>
<td>指示数据链路层协议将持续监听对方的回应，直到得到答复。它仅能用于SOCK_DGRAM和SOCK_RAW类型的socket</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>不查看路由表，直接将数据发送给本地局域网络内的主机。这表示发送者确切地知道目标主机就在本地网络上</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>对socket的此次操作将会是非阻塞的</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送。这样可防止TCP发送过多小的报文段，从而提高传输效率。</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>读操作仅在读取到指定数量的字节后才返回</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>窥探读缓存中的数据，此次读操作不会导致这些数据被清除</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>发送或接收紧急数据</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>往读端关闭的管道或者socket连接中写数据时不引发SIGPIPE信号</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<p>接下来来举例如何使用这些选项。MSG_OOB选项给应用程序提供了发送和接收带外数据的方法，发送端和接收端代码如下：</p>
<p>发送端：发送带外数据【客户端执行】&lt;testoobsend.c&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number\n"</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert( sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connection failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *oob_data = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *normal_data = <span class="string">"123"</span>;</span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">        send(sockfd, oob_data, <span class="built_in">strlen</span>(oob_data), MSG_OOB);</span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收端：接收带外数据【服务端执行】&lt;testoobrecv.c&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is:%d\n"</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">buffer</span>[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'\0'</span>, BUF_SIZE);</span><br><span class="line">        ret = recv(connfd, <span class="built_in">buffer</span>, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"got %d bytes of normal data '%s'\n"</span>,ret,<span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'\0'</span>, BUF_SIZE);</span><br><span class="line">        ret = recv(connfd, <span class="built_in">buffer</span>, BUF_SIZE<span class="number">-1</span>, MSG_OOB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"got %d bytes of oob data '%s'\n"</span>,ret, <span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'\0'</span>, BUF_SIZE);</span><br><span class="line">        ret = recv(connfd, <span class="built_in">buffer</span>, BUF_SIZE<span class="number">-1</span>, MSG_OOB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"got %d bytes of normal data '%s'\n"</span>,ret, <span class="built_in">buffer</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用之前的网络来进行测试，首先在服务器（192.168.141.137）上启动服务器程序（testoobrecv），然后到客户端（192.168.141.139）上执行客户端程序（testoobsend），具体如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器执行</span></span><br><span class="line">$ ./testoobrecv 192.168.141.137 54321</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端执行</span></span><br><span class="line">$ ./testoobsend 192.168.141.137 54321</span><br></pre></td></tr></table></figure>

<p>得到服务器的输出：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/6c7ce0a40eff6624.webp" alt=""></p>
<p>由此可见，客户端发送给服务器的3字节带外数据“abc”中，仅有<strong>最后一个字符</strong>“c”被服务器当成真正的带外数据接收（如上一章TCP带外数据的一节中所述，即带外缓冲区只有一个字节）。并且，<strong>服务器对正常数据的接收将被带外数据截断</strong>，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<p>值得一提的是，<strong><em>flags</em>参数只对<code>send</code>和<code>recv</code>的当前调用生效</strong>，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。</p>
<h4 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h4><p>socket编程接口中用于UDP数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvform</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>recvfrom</code>读取<strong><em>sockfd</em></strong>上的数据，<strong><em>buf</em></strong>和<strong><em>len</em></strong>参数分别指定读缓冲区的位置和大小。【<strong>因为UDP通信没有连接的概念</strong>】，所以我们每次读取数据都需要获取发送端的socket地址，即参数<strong><em>src_addr</em></strong>所指内容，<strong><em>addrlen</em></strong>参数则指定该地址的长度。</p>
<p><code>sendto</code>往<strong><em>sockfd</em></strong>上写入数据，<strong><em>buf</em></strong>和<strong><em>len</em></strong>参数分别指定写缓冲区的位置和大小。<strong><em>dest_addr</em></strong>参数指定接收端的socket地址，<strong><em>addrlen</em></strong>参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</p>
<p>值得一提的是，recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址就可以了（因为面向连接已经与对方建立了连接，socket地址已知）。</p>
<h4 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h4><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数指定被操作的目标socket。</p>
<p><strong><em>msg</em></strong>参数是<code>msghdr</code>结构体类型的指针，<code>msghdr</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *msg_name;             <span class="comment">/* socket地址 */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen;      <span class="comment">/* socket地址的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>      <span class="comment">/* 分散的内存块（数组），详见后文 */</span></span><br><span class="line">    <span class="keyword">int</span> msg_iovlen;             <span class="comment">/* 分散数据块的数量 */</span></span><br><span class="line">    <span class="keyword">void</span> *msg_control;          <span class="comment">/* 指向辅助数据的起始位置 */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen;   <span class="comment">/* 辅助数据的大小 */</span></span><br><span class="line">    <span class="keyword">int</span> msg_flags;              <span class="comment">/* 复制函数中的flags参数，并在调用过程中更新 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><em>msg_name</em></strong>成员指向一个socket地址结构变量。它指定通信<strong>对方</strong>的socket地址（对于面向连接的TCP协议，该成员必须被设置为NULL，因为对方socket已知）。<strong><em>msg_namelen</em></strong>成员则指定了msg_name所指socket地址的长度。</p>
<p><strong><em>msg_iov</em></strong>成员是iovec结构体类型的指针，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base;             <span class="comment">/* 内存起始地址 */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;             <span class="comment">/* 这块内存的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iovec</code>结构体封装了一块内存的起始地址和长度。</p>
<p><strong><em>msg_iovlen</em></strong>则指定这样的<code>iovec</code>结构对象有多少个。</p>
<blockquote>
<p>对于<code>recvmsg</code>而言，数据将被读取并存在<em>msg_iovlen</em>块分散的内存中，这些内存的位置和长度由<em>msg_iov</em>指向的数组指定，这称为分散读（scatter read）。</p>
<p>对于<code>sendmsg</code>而言，<em>msg_iovlen</em>块分散内存中的数据将被一并发送，这称为集中写（gather write）。</p>
</blockquote>
<p><em>msg_control</em>和<em>msg_controllen</em>成员用于辅助数据的传送。我们将在后面介绍如何使用它们来实现<strong>进程间传递文件描述符</strong>。</p>
<p>msg_flags成员无须设定，会复制函数中的flags参数内容。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。flags参数与send/recv的flags参数以及返回值相同。</p>
<h3 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h3><p>在“TCP数据读写”中演示了TCP带外数据的接收方法。但是在实际应用中，无法预期带外数据何时到来。而这一点可以通过sockatmark系统调用来检测紧急标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>sockatmark</code>判断<strong><em>sockfd</em></strong>是否处于带外标记，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回<code>1</code>，此时就可以<strong>利用带MSG_OOB标志的<code>recv</code>调用来接收带外数据</strong>。如果不是，则sockatmark返回<code>0</code>。</p>
<p>Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方法是：I/O复用产生的异常事件 和 SIGURG信号。</p>
<h3 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h3><p>若想知道一个连接socket的本端socket地址，以及远端的socket地址。下面两个函数可以解决这个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *address, <span class="keyword">socklen_t</span> *address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *address, <span class="keyword">socklen_t</span> *address_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>getsockname</code>获取<strong><em>sockfd</em></strong>对应的<strong>本端</strong>socket地址，并将其存储于<strong><em>address</em></strong>参数指定的内存中，该地址的长度存储于<strong><em>address_len</em></strong>参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回<code>0</code>，失败返回<code>-1</code>并设置errno。</p>
<p><code>getpeername</code>获取<strong><em>sockfd</em></strong>对应的<strong>远端</strong>socket地址，其参数及返回值含义与getsockname相同。</p>
<h3 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h3><p><code>fcntl</code>系统调用是控制文件描述符属性的通用POSIX方法，而下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span> *option_value, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span> *option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>sockfd</em></strong>参数指定被操作的目标socket。</p>
<p><strong><em>level</em></strong>参数指定要操作哪个协议的选项，比如IPv4、IPv6、TCP等。</p>
<p><strong><em>option_name</em></strong>参数则指定选项的名字。<strong><em>option_value</em></strong>和<strong><em>option_len</em></strong>参数分别是被操作选项的值和长度，不同的选项具有不同类型的值。</p>
<p><code>getsockopt</code>和<code>setsockopt</code>两个函数成功时返回<code>0</code>，失败时返回<code>-1</code>并设置errno。</p>
<p>下面列出一些常用的socket选项：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/10bd37578ba77787.webp" alt="常用socket选项"></p>
<p>值得一提，<strong>有部分socket选项只能在调用listen系统调用前针对监听socket设置才有效</strong>。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤（连接至少进入SYN_RCVD状态），这说明接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。</p>
<p>对于这种情况，Linux提供的解决方案是：<strong>对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项</strong>。这些socket选项包括：SO_DEBUG, SO_DONTROUTE, SO_KEEPALIVE, SO_LINGER, SO_OOBINLINE, SO_RCVBUF, SO_RCVLOWAT, SO_SNDBUF, SO_SNDLOWAT, TCP_MAXSEG和TCP_NODELAY。</p>
<p>而对于客户端来说，这些socket选项需要在connect函数执行前设置，因为connect调用成功之后，TCP三次握手已经完成。</p>
<p>下面来详细讨论部分重要的socket选项：</p>
<ul>
<li><p><code>SO_REUSEADDR</code>：服务器程序可以通过SO_REUSEADDR选项来<strong>强制使用被处于TIME_WAIT状态的连接占用的socket地址</strong>。</p>
</li>
<li><p><code>SO_RCVBUF</code>和<code>SO_SNDBUF</code>：分别表示TCP接收缓冲区和发送缓冲区的大小。<strong>当用setsockopt来设置TCP的接收缓冲区和发送缓冲区大小时，系统都会将其值加倍，并且不得小于某个最小值</strong>。（TCP接收缓冲区最小值是256字节，发送缓冲区最小值是2048字节）</p>
</li>
<li><p><code>SO_RCVLOWAT</code>和<code>SO_SNDLOWAT</code>：分别表示TCP接收缓冲区和发送缓冲区的低水位标记。它们一般被<strong>I/O复用系统调用用来判断socket是否可读或可写</strong>。当TCP接收缓冲区中可读数据总数大于其低水位标记时，I/O复用系统调用将通知应用程序可从对应的socket上读取数据；当TCP发送缓冲区中的空闲空间大于其低水位标记时，通知应用程序可在对应socket上写入数据。</p>
</li>
<li><p><code>SO_LINGER</code>：该选项用于<strong>控制close系统调用在关闭TCP连接时的行为</strong>。默认情况下，使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>在设置（获取）SO_LINGER选项的值时，需要给系统调用传递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">strcut linger</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> l_onoff;             <span class="comment">/* 开启（非0）还是关闭（0）该选项 */</span></span><br><span class="line">	<span class="keyword">int</span> l_linger;            <span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据linger结构体中两个成员变量的不同值，close系统调用可能产生如下3种行为之一：</p>
<ol>
<li>l_onoff等于0：close用默认行为来关闭socket</li>
<li>l_onoff不为0，l_linger等于0：此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。这种情况给服务器提供了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0：此时close的行为取决于两个条件：（1）被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；（2）该socket是阻塞的还是非阻塞的。</li>
</ol>
</li>
</ul>
<h3 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h3><p>socket地址的两个要素：IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（从IPv4转移到IPv6）。可以通过网络信息API，用主机名代替IP地址，用服务名称来代替端口号，如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>

<p>这两条telnet命令具有完全相同的作用（telnet客户端通过网络信息API实现了主机名到IP地址，服务名称到端口号的转换）。</p>
<h4 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h4><p><code>gethostbyname</code>函数根据主机名称获取主机的完整信息，通常先在本地的<code>/etc/hosts</code>配置文件中查找主机，如果没有找到，再去访问DNS服务器。而<code>gethostbyaddr</code>函数根据IP地址获取主机完整信息。两个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>name</em></strong>参数指定目标主机的主机名。</p>
<p><strong><em>addr</em></strong>参数指定目标主机的IP地址，<strong><em>len</em></strong>参数指定所指IP地址的长度，<strong><em>type</em></strong>参数指定addr所指IP地址的类型（AF_INET和AF_INET6）。</p>
<p>两个函数返回的都是<code>hostent</code>结构体类型的指针，该结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;              <span class="comment">/* 主机名 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;          <span class="comment">/* 主机别名列表，可能有多个 */</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;            <span class="comment">/* 地址类型（地址族） */</span></span><br><span class="line">    <span class="keyword">int</span> h_length;              <span class="comment">/* 地址长度 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;        <span class="comment">/* 按网络字节序列出的主机IP地址列表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h4><p><code>getservbyname</code>函数根据服务名称获取某个服务的完整信息，<code>getservbyport</code>函数根据端口号获取某个服务的完整信息。他们实际上都是通过读取<code>/etc/services</code>文件来获取服务的信息的。这两个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>name</em></strong>参数指定目标服务的名称。</p>
<p><strong><em>port</em></strong>参数指定目标服务对应的端口号。</p>
<p><strong><em>proto</em></strong>参数指定服务类型，可选参数：（1）“tcp”，表示获取流服务；（2）“udp”，表示获取数据报服务；（3）NULL，表示获取所有类型的服务。</p>
<p>这两个函数返回的都是<code>servent</code>结构体类型的指针，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *s_name;               <span class="comment">/* 服务名称 */</span></span><br><span class="line">    <span class="keyword">char</span> **s_aliases;           <span class="comment">/* 服务的别名列表，可能有多个 */</span></span><br><span class="line">    <span class="keyword">int</span> s_port;                 <span class="comment">/* 端口号（网络字节序） */</span></span><br><span class="line">    <span class="keyword">char</span> *s_proto;              <span class="comment">/* 服务类型，通常是tcp或者udp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别注意：以上四个函数都是不可重入的，即非线程安全的。</p>
</blockquote>
<p>不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r （re-entrant）。</p>
<p>接下来，我们通过主机名和服务名来访问服务器上的<code>daytime</code>服务，以获取该机器的系统时间。</p>
<p>先启动服务器（192.168.141.137）上的<code>daytime</code>服务并进行本地测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/xinetd.d/daytime</span><br><span class="line"><span class="comment"># 将disable配置项由yes修改为no</span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">$ sudo /etc/init.d/xinetd restart</span><br><span class="line"><span class="comment"># 本地测试</span></span><br><span class="line">$ nc localhost daytime</span><br></pre></td></tr></table></figure>

<p>再在客户端（192.168.141.139）上为服务器配置一个主机名，到hosts文件中配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/hosts</span><br><span class="line"><span class="comment"># 添加一行：192.168.141.137 server</span></span><br></pre></td></tr></table></figure>

<p>在客户端编写代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert(argc == <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">/* 获取目标主机地址信息 (/etc/hosts)*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostinfo</span>= <span class="title">gethostbyname</span>(<span class="title">host</span>);</span></span><br><span class="line">	assert(hostinfo);</span><br><span class="line">	<span class="comment">/* 获取daytime服务信息 (/etc/services)*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> = <span class="title">getservbyname</span>("<span class="title">daytime</span>","<span class="title">tcp</span>");</span></span><br><span class="line">	assert(servinfo);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"daytime port is %d\n"</span>, ntohs(servinfo-&gt;s_port));</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">	address.sin_addr = *(struct in_addr*)*hostinfo-&gt;h_addr_list;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(result != <span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">128</span>];</span><br><span class="line">	result = <span class="built_in">read</span>(sockfd, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>));</span><br><span class="line">	assert(result &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">buffer</span>[result] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the day time is : %s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">	<span class="built_in">close</span>(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端中编译运行代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc testconndaytime.c -o testconndaytime</span><br><span class="line">$ ./testconndaytime server</span><br></pre></td></tr></table></figure>

<p>得到的输出如下：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/1439a8b7de399643.webp" alt="输出结果"></p>
<h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><p>该函数既能通过主机名获得IP地址（内部使用gethostbyname），也可以通过服务名获得端口号（内部使用getservbyname）。该函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo **result)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>hostname</em></strong>参数可以接收主机名，也可以接收字符串表示的IP地址。</p>
<p><strong><em>service</em></strong>参数可以接收服务名，也可以接收字符串表示的十进制端口号。</p>
<p><strong><em>hints</em></strong>参数是应用程序给getaddrinfo的一个提示，以对其输出进行更精确的控制。可以设置为NULL，表示允许函数反馈任何可用的结果。</p>
<p><strong><em>result</em></strong>参数指向一个链表，该链表用于存储函数反馈的结果。能够被隐式地分配堆内存，所以getaddrinfo调用结束后，必须使用如下配对函数来释放这块内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>addrinfo</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai_flags;             </span><br><span class="line">    <span class="keyword">int</span> ai_family;             <span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="keyword">int</span> ai_socktype;           <span class="comment">/* 服务类型：SOCK_STREAM或SOCK_DGRAM */</span></span><br><span class="line">    <span class="keyword">int</span> ai_protocol;</span><br><span class="line">    <span class="keyword">socklen_t</span> ai_addrlen;      <span class="comment">/* socket地址ai_addr的长度 */</span></span><br><span class="line">    <span class="keyword">char</span> *ai_canonname;        <span class="comment">/* 主机的别名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>  <span class="comment">/* 指向socket地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>  <span class="comment">/* 指向下一个sockinfo结构的对象 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当使用<code>hints</code>参数时，可以设置其ai_flags, ai_family, ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p>
<h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><p>该函数能通过socket地址同时获得以字符串表示的主机名（内部使用gethostbyaddr），和服务名（内部使用getservbyport）。该函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span> *host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span> *serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>



<p>9月8日，今天把最“苦”的任务顺利完结了，然而没有更多的时间留给linux学习，今天便稍作复习。加油(ง •_•)ง</p>
<h2 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h2><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数那么常用，但是在特定的条件下却表现出优秀的性能。本章讨论其中和网络编程相关的几个，这些函数大致分为三类：</p>
<ul>
<li>用于创建文件描述符的函数，包括 <strong>pipe</strong>、<strong>dup/dup2</strong> 函数。</li>
<li>用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。</li>
<li>用于控制I/O行为和属性的函数，包括fcntl函数。</li>
</ul>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p><code>pipe</code>函数可用于创建一个管道，以<strong>实现进程间通信</strong>。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>fd</em></strong>参数是一个包含两个<code>int</code>型整数的<u>数组指针</u>。</p>
<p><code>pipe</code>函数成功时返回<code>0</code>，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回<code>-1</code>并设置errno。</p>
<p>通过pipe函数创建的这两个文件描述符<code>fd[0]</code>和<code>fd[1]</code>分别构成管道的两端，并且，<strong><code>fd[0]</code>只能用于从管道读出数据，<code>fd[1]</code>则只能用于往管道写入数据，而不能反过来使用</strong>。如果要实现双向的数据传输，就应该使用两个管道。</p>
<p>默认情况下，这一对文件描述符都是<strong>阻塞</strong>的。如果用<code>read</code>系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读；用write系统调用往一个满的管道中写入数据，则write亦将被阻塞，直到管道内有足够多的空闲空间可用。但如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。</p>
<p>如果管道的写端文件描述符<code>fd[1]</code>的<u>引用计数</u>减少至<code>0</code>，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符<code>fd[0]</code>的read操作将返回<code>0</code>，即读到了文件结束标记（End Of File，EOF）；反之，如果管道的读端文件描述符<code>fd[0]</code>的引用计数减少至<code>0</code>，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符<code>fd[1]</code>的write操作将<code>失败</code>，并引发SIGPIPE信号。</p>
<p>管道内部传输的数据是<strong>字节流</strong>，且拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。（自Linux内核 2.6.11起，管道容量的大小默认是65536字节）。我们可以使用<code>fcntl</code>函数来修改管道容量。</p>
<p>此外，socket的基础API中有一个<code>socketpair</code>函数。它<strong>能够方便地创建双向管道</strong>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>前三个参数的含义与socket系统调用的三个参数完全相同，但<strong><em>domain</em></strong>只能使用UNIX本地域协议族<code>AF_UNIX</code>，因为我们<strong>仅能在本地使用这个双向管道</strong>。</p>
<p>最后一个参数则和<code>pipe</code>系统调用的参数一样，只不过<code>socketpair</code>创建的这对文件描述符都是<strong>既可读又可写的</strong>。<code>socketpair</code>成功时返回<code>0</code>，失败时返回<code>-1</code>并设置errno。</p>
<h3 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h3><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。这可以通过下面的用于<strong>复制文件描述符</strong>的<code>dup</code>或<code>dup2</code>函数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one, <span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>dup</code>函数<strong>创建一个新的文件描述符</strong>，新文件描述符和原有文件描述符<strong><em>file_descriptor</em></strong>指向相同的文件、管道或者网络连接。并且<code>dup</code><strong>返回的文件描述符总是取系统当前可用的最小整数值</strong>。</p>
<p><code>dup2</code>和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回<code>-1</code>并设置errno。</p>
<blockquote>
<p>注意：通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。</p>
</blockquote>
<p>下面用<code>dup</code>函数实现了一个基本的CGI服务器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number\n"</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is: %d\n"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">        dup(connfd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abcd\n"</span>);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用之前的网络进行测试，服务器（192.168.141.137）先编译运行此代码，等待客户端进行连接；客户端（192.168.141.139）使用nc命令连接服务端对应端口。操作步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line">$ gcc testCGI.c -o testCGI</span><br><span class="line">$ ./testCGI 192.168.141.137 54322</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">$ nc 192.168.141.137 54322</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/09/09/UF3OceasYfAhlWB.png" alt="客户端输出结果"></p>
<p>可以看到，服务器已经将标准输出内容重定向到网络连接，而在客户端的命令行中显示出来了。</p>
<p>过程中，我们先<strong>关闭</strong>标准输出文件描述符<code>STDOUT_FILENO</code>（其值是<code>1</code>），然后<strong>复制</strong>socket文件描述符<code>connfd</code>。因为<code>dup</code>总是<strong>返回系统中最小的可用文件描述符</strong>，所以它的返回值实际上是1，即之前关闭的标准输出文件描述符的值。这样一来，服务器输出到标准输出的内容（“abcd\n”）就会直接发送到与客户端连接对应的socket上，因此<code>printf</code>调用的输出将被客户端获得（而不是显示在服务器程序的终端上）。这就是CGI服务器的基本工作原理。</p>
<h3 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h3><p><code>readv</code>函数将数据从文件描述符读到<u>分散的</u>内存块中，即<strong>分散读</strong>；<code>writev</code>函数则将多块<u>分散的</u>内存数据一并写入文件描述符中，即<strong>集中写</strong>。（与bio的io形式很相似）。它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>fd</em></strong>参数是被操作的目标文件描述符。</p>
<p><strong><em>vector</em></strong>参数的类型是<code>iovec</code>结构数组，用来描述一块内存区。其定义如下（之前也写过，再写一遍）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base;             <span class="comment">/* 内存起始地址 */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;             <span class="comment">/* 这块内存的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><em>count</em></strong>参数是<code>vector</code>数组的长度，即有多少<strong>块</strong>内存数据需要从fd读出或者写入。</p>
<p><code>readv</code>和<code>writev</code>在成功时返回读出/写入fd的<strong>字节数</strong>，失败则返回<code>-1</code>并设置errno。</p>
<p>考虑对于Web服务器，当Web服务器解析完一个HTTP请求之后，如果目标文档存在并且客户具有读取文档的权限，那么它就需要发送一个HTTP应答来传输文档。HTTP应答包含一个状态行、多个头部字段、1个空行和文档内容。其中前3部分内容可能被Web服务器放在一块内存中，而文档内容则通常被读入到另一块单独的内存中（通过read函数或者mmap函数）。<strong>我们并不需要把这两部分内容拼接在一起再发送，而是可以使用writev函数将它们同时写出</strong>。</p>
<p>我们可以通过下面的程序来体验<code>writev</code>的功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="comment">// 定义两种HTTP状态码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *status_line[<span class="number">2</span>] = &#123;<span class="string">"200 OK"</span>, <span class="string">"500 Internal server errno"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number filename\n"</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 将目标文件作为程序的第三个参数传入</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET,ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is %\n"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保存HTTP应答的状态行、头部字段和一个空行的缓冲区</span></span><br><span class="line">        <span class="keyword">char</span> header_buf[BUFFER_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>(header_buf, <span class="string">'\0'</span>, BUFFER_SIZE);</span><br><span class="line">        <span class="comment">// 保存文件内容</span></span><br><span class="line">        <span class="keyword">char</span> *file_buf;</span><br><span class="line">        <span class="comment">// 用于获取目标文件内容的应用程序缓存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">        <span class="comment">// 记录目标文件是否是有效文件</span></span><br><span class="line">        <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 缓冲区已使用的字节数</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(stat(file_name, &amp;file_stat) &lt; <span class="number">0</span>) <span class="comment">// 目标文件不存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S_ISDIR(file_stat.st_mode)) <span class="comment">// 目标文件是一个目录</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(file_stat.st_mode &amp; S_IROTH)  <span class="comment">// 当前用户有读取目标文件的权限</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = <span class="built_in">open</span>(file_name, O_RDONLY);</span><br><span class="line">                file_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((file_stat.st_size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">                <span class="built_in">memset</span>(file_buf,<span class="string">'\0'</span>,file_stat.st_size+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">read</span>(fd,file_buf,file_stat.st_size+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(valid)  <span class="comment">// 有效则发送HTTP应答</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>(header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">"%s %s\r\n"</span>,<span class="string">"HTTP/1.1"</span>,status_line[<span class="number">0</span>]);</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>(header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">"Content-Length: %d\r\n"</span>,file_stat.st_size);</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>(header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">"%s"</span>,<span class="string">"\r\n"</span>);</span><br><span class="line">            <span class="comment">// 利用writev将header_buf和file_buf内容一并写出</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iv</span>[2];</span></span><br><span class="line">            iv[<span class="number">0</span>].iov_base = header_buf;</span><br><span class="line">            iv[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(header_buf);</span><br><span class="line">            iv[<span class="number">1</span>].iov_base = file_buf;</span><br><span class="line">            iv[<span class="number">1</span>].iov_len = file_stat.st_size;</span><br><span class="line">            ret = writev(connfd, iv, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>(header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">"%s %s\r\n"</span>,<span class="string">"HTTP/1.1"</span>, status_line[<span class="number">1</span>]);</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>(header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">"%s"</span>, <span class="string">"\r\n"</span>);</span><br><span class="line">            send(connfd, header_buf,<span class="built_in">strlen</span>(header_buf),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">        <span class="built_in">free</span>(file_buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用之前的网络进行测试，服务器（192.168.141.137）在代码的同一个文件夹中创建一个testfile.txt文件，写一些话（注意使user有权限，可以chmod修改权限），然后编译运行该代码。客户端通过nc命令向服务器发起连接。具体过程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line">$ gcc testwritev.c -o testwritev</span><br><span class="line">$ chmod 777 testfile.txt</span><br><span class="line">$ ./testwritev 192.168.141.137 54321 testfile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">$ nc 192.168.141.137 54321</span><br></pre></td></tr></table></figure>

<p>在客户端得到服务器上的文件内容：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/03ad7efacc0dc541.png" alt=""></p>
<p>可以看出，得到了期望的结果。</p>
<h3 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h3><p><code>sendfile</code>函数在<strong>两个文件描述符之间直接传递数据</strong>（完全在内核中操作），从而<strong>避免了内核缓冲区和用户缓冲区之间的数据拷贝</strong>，效率很高，这被称为<code>零拷贝</code>。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>in_fd</em></strong>参数是<u>待读出</u>内容的文件描述符，<strong><em>out_fd</em></strong>参数是<u>待写入</u>内容的文件描述符。</p>
<p><strong><em>offset</em></strong>参数指定从读入文件流的哪个位置开始读，如果为空，则默认是读入文件流的起始位置。</p>
<p><strong><em>count</em></strong>参数指定在文件描述符in_fd和out_fd之间传输的字节数。</p>
<p><code>sendfile</code>调用成功返回<u>传输的字节数</u>，失败则返回<code>-1</code>并设置errno。</p>
<blockquote>
<p>注意：该函数的man手册指出，<code>in_fd</code>必须是一个支持类似<code>mmap</code>函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而<code>out_fd</code>则必须是一个socket。由此可见，<code>sendfile</code>几乎是专门为网络上传输文件而设计的。</p>
</blockquote>
<p>下面我们使用<code>sendfile</code>函数将服务器（192.168.141.137）上的一个文件传送给客户端（192.168.141.139）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number filename\n"</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>(file_name, O_RDONLY);</span><br><span class="line">    assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is %d\n"</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sendfile(connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器在代码目录下建立一个文件demofile.txt，写一些内容，然后编译运行上面代码，等待客户端连接。具体操作流程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line">$ vim demofile.txt   <span class="comment"># 写一些内容</span></span><br><span class="line">$ chmod 777 demofile.txt       <span class="comment"># 保证拥有足够的权限</span></span><br><span class="line">$ gcc testsendfile.c -o testsendfile</span><br><span class="line">$ ./testsendfile 192.168.141.137 54321 demofile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">$ nc 192.168.141.137 54321</span><br></pre></td></tr></table></figure>

<p>然后就可以在客户端的命令行中得到预期的结果，即客户端获取到了服务器上目标文件的内容：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/e2652bba6436c9fd.png" alt=""></p>
<p><code>sendfile</code>相比readv和writev函数，<u>并没有为目标文件分配任何用户空间的缓存</u>，<u>也没有执行读取文件的操作</u>，但同样实现了文件的发送，其效率显然更高。</p>
<h3 id="mmap函数和munmap函数"><a href="#mmap函数和munmap函数" class="headerlink" title="mmap函数和munmap函数"></a>mmap函数和munmap函数</h3><p><code>mmap</code>函数用于申请一段内存空间。可以将这段内存作为<strong>进程间通信的共享内存</strong>，也可以<u>将文件直接映射到其中</u>。<code>munmap</code>函数则<strong>释放</strong>由<code>mmap</code>创建的这段内存空间。它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>start</em></strong>参数允许用户使用某个特定的地址作为这段内存的起始地址，如果它被设置成NULL，则系统自动分配一个地址。</p>
<p><strong><em>length</em></strong>参数指定内存段的长度。</p>
<p><strong><em>prot</em></strong>参数用来设置内存段的访问权限，它可以取以下几个值的按位或：</p>
<ul>
<li>PROT_READ，内存段可读</li>
<li>PROT_WRITE，内存段可写</li>
<li>PROT_EXEC，内存段可执行</li>
<li>PROT_NONE，内存段不能被访问</li>
</ul>
<p><strong><em>flags</em></strong>参数控制<u>内存段内容被修改后程序的行为</u>，它可以被设置为下表中某些值的按位或（仅列出了常用的值，其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p>
<table>
<thead>
<tr>
<th>常用值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MAP_SHARED</td>
<td>在进程间共享这段内存。对该内存段的修改将反映到被映射的文件中。它提供了进程间共享内存的POSIX方法。</td>
</tr>
<tr>
<td>MAP_PRIVATE</td>
<td>内存段为调用进程所私有。对该内存段的修改不会反映到被映射的文件中。</td>
</tr>
<tr>
<td>MAP_ANONYMOUS</td>
<td>这段内存不是从文件映射而来的。其内容被初始化为全0。这种情况下，mmap函数的最后两个参数将被忽略。</td>
</tr>
<tr>
<td>MAP_FIXED</td>
<td>内存段必须位于start参数指定的地址处。start必须是内存页面大小（4096字节）的整数倍。</td>
</tr>
<tr>
<td>MAP_HUGETLB</td>
<td>按照“大内存页面”来分配内存空间。“大内存页面”的大小可通过/proc/meminfo文件来查看。</td>
</tr>
</tbody></table>
<p><strong><em>fd</em></strong>参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p>
<p><strong><em>offset</em></strong>参数设置从文件的何处开始映射（对于不需要读入整个文件的情况）。</p>
<p><code>mmap</code>函数成功时返回<u>指向目标内存区域的指针</u>，失败则返回<code>MAP_FAILED</code>（(void*)-1）并设置errno。</p>
<p><code>munmap</code>函数成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。</p>
<p>我们将在后面进一步利用<code>mmap</code>函数来实现<strong>进程间共享内存</strong>。</p>
<h3 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h3><p><code>splice</code>函数用于在<strong>两个文件描述符之间移动数据</strong>，也是<strong>零拷贝</strong>操作。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>fd_in</em></strong>参数是待<strong>输入数据的文件描述符</strong>。如果fd_in是一个管道文件描述符，则<strong><em>off_in</em></strong>参数必须设置为NULL，若不是管道文件描述符，则表示输入数据流从何处开始读取数据（此时若将off_in设置为NULL，则表示从输入流的当前偏移位置读入）。</p>
<p><strong><em>fd_out</em></strong>/<strong><em>off_out</em></strong>参数的含义与fd_in/off_in相似，不过用于<strong>输出数据流</strong>。</p>
<p><strong><em>len</em></strong>参数指定移动数据的长度；而<strong><em>flags</em></strong>参数控制数据如何移动，可以被设置成下表某些值的按位或。</p>
<table>
<thead>
<tr>
<th>常用值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SPLICE_F_MOVE</td>
<td>如果合适的话，按整页内存移动数据。这只是给内核一个提示。不过，它的实现存在bug，自内核2.6.21后，实际上没有效果。</td>
</tr>
<tr>
<td>SPLICE_F_NONBLOCK</td>
<td>非阻塞的splice操作，但实际效果还会受文件描述符本身的阻塞状态影响。</td>
</tr>
<tr>
<td>SPLICE_F_MORE</td>
<td>给内核一个提示：后续的splice调用将读取更多数据</td>
</tr>
<tr>
<td>SPLICE_F_GIFT</td>
<td>对splice没有效果</td>
</tr>
</tbody></table>
<p>使用<code>splice</code>函数时，<code>fd_in</code>和<code>fd_out</code>必须<strong>至少</strong>有一个是管道文件描述符。<code>splice</code>函数调用成功时返回移动字节的数量（可能是0，表示没有数据需要移动，发送在从管道中读取数据，而没有被写入任何数据时）。调用失败时返回-1并设置errno。常见的errno见下表：</p>
<table>
<thead>
<tr>
<th>错误</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EBADF</td>
<td>参数所指文件描述符有错</td>
</tr>
<tr>
<td>EINVAL</td>
<td>目标文件系统不支持splice，或者目标文件以追加方式打开，或者两个文件描述符都不是管道文件描述符，或者某个offset参数被用于不支持随机访问的设备（如字符设备）</td>
</tr>
<tr>
<td>ENOMEM</td>
<td>内存不够</td>
</tr>
<tr>
<td>ESPIPE</td>
<td>参数fd_in(或fd_out)是管道，但off_in(或off_out)不为NULL</td>
</tr>
</tbody></table>
<p>下面使用<code>splice</code>函数来实现一个<strong>零拷贝的回射服务器</strong>，它<u>将客户端发送的数据原样返回到客户端</u>，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1            <span class="comment">// 这行要加，不然SPLICE_F_xxx宏无法编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s ip_address port_number\n"</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sock,(struct sockaddr*)&amp;client, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is %d\n"</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        ret = pipe(pipefd);   <span class="comment">// 创建管道</span></span><br><span class="line">        ret = splice(connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器（192.168.141.137）编译运行代码，等待客户端连接并发送数据，客户端的命令行中将回显自己发送的数据。运行结果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/074749227db74587.webp" alt=""></p>
<p>在过程中，通过<code>splice</code>函数将客户端的内容读入到<code>pipefd[1]</code>中，然后再使用<code>splice</code>函数从<code>pipefd[0]</code>中读出该内容到客户端，从而实现了简单高效的回射服务。整个过程未执行recv/send操作，也未涉及用户空间和内核空间之间的数据拷贝。</p>
<h3 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h3><p><code>tee</code>函数在<strong>两个管道文件描述符之间复制数据</strong>，也是<strong>零拷贝</strong>操作。它不消耗数据（<code>splice</code>的移动操作会消耗数据），因此，源文件描述符上的数据仍然可以用于后续的读操作。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">int</span> fd_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数参数的含义与<code>splice</code>相同（<strong>但fd_in和fd_out必须都是管道文件描述符</strong>）。<code>tee</code>调用成功返回在两个文件描述符之间复制的字节数（返回0表示没有复制任何数据），失败则返回<code>-1</code>并设置errno。</p>
<p>下面使用<code>tee</code>函数与<code>splice</code>函数，实现linux中的<code>tee程序</code>（将标准输入同时输出到终端和文件的程序）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s &lt;file&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_CREAT|O_WRONLY|O_TRUNC,<span class="number">0666</span>);</span><br><span class="line">    assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd_stdout);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">    ret = pipe(pipefd_file);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将标准输入内容输入管道</span></span><br><span class="line">    ret = splice(STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 将pipefd_stdout的读端复制到管道pipe_file的写端</span></span><br><span class="line">    ret = splice(pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, pipefd_file[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_NONBLOCK);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 将管道pipefd_file的输出定向到文件描述符filefd上，实现将标准输入的内容写入文件</span></span><br><span class="line">    ret = splice(pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 将管道pipefd_stdout的输出定向到标准输出上</span></span><br><span class="line">    ret = splice(pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(filefd);</span><br><span class="line">    <span class="built_in">close</span>(pipefd_stdout[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefd_stdout[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefd_file[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefd_file[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在管道间复制数据，并不会消耗管道的数据。</p>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p><code>fcntl</code>函数提供了对文件描述符的各种控制操作。另一个常见的控制文件描述符属性和行为的系统调用是<code>ioctl</code>，而且<code>ioctl</code>比<code>fcntl</code>能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<code>fcntl</code>函数是由POSIX规范指定的首选方法。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>fd</em></strong>参数是被操作的文件描述符。</p>
<p><strong><em>cmd</em></strong>参数指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数<strong><em>arg</em></strong>。</p>
<p><strong><em>fcntl</em></strong>支持的常用操作及其参数如下表所示：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/80cba702666958b8.webp" alt="fcntl常用操作"></p>
<p><code>fcntl</code>调用成功时返回值如上表最后一列所示，失败则返回<code>-1</code>并设置errno。</p>
<p>在网络编程中，<code>fcntl</code>函数通常用来<u>将一个文件描述符设置为非阻塞的</u>，可以这样实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);       <span class="comment">/* 获取文件描述符旧的状态标志 */</span></span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;  <span class="comment">/* 设置非阻塞标志 */</span></span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;                         <span class="comment">/* 返回旧的描述符状态，以便日后恢复其状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Linux服务器程序规范"><a href="#Linux服务器程序规范" class="headerlink" title="Linux服务器程序规范"></a>Linux服务器程序规范</h2><blockquote>
<p>期待后续更新。。   ——0917</p>
</blockquote>
<blockquote>
<p>更新来了！ ——0923</p>
</blockquote>
<p>服务器程序规范，指除了网络通信外，服务器程序通常还必须考虑的一些模板式的细节问题，包括：</p>
<ul>
<li>Linux服务器程序一般以<strong>后台进程</strong>（守护进程—daemon）形式运行。守护进程的父进程通常是<code>init</code>进程（PID为1的进程）。</li>
<li>Linux服务器程序通常有一套<strong>日志系</strong>统（在/var/log目录下），至少能输出日志到文件。</li>
<li>服务器程序一般以某个<strong>专门的非root身份</strong>运行。比如mysqld、httpd等后台进程，分别拥有自己的运行账户mysql、apache。</li>
<li>服务器程序通常是<strong>可配置</strong>的，需要处理很多命令行选项，若一次运行的选项太多就可以用配置文件来管理（存放在/etc目录下）。</li>
<li>Linux服务器进程通常会在启动的时候<strong>生成一个PID文件</strong>并存入/var/run目录中，以记录该后台进程的PID。</li>
<li>服务器程序通常需要考虑<strong>系统资源和限制</strong>，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li>
</ul>
<p>下面来探讨一些主要的规范。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h4><p>Linux提供一个<strong>守护进程</strong>来处理系统日志——syslogd，不过现在Linux系统上使用的都是它的升级版——<code>rsyslogd</code>。rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。下面是Linux的系统日志体系：</p>
<p><img src= "/img/loading.gif" data-src="https://s3.bmp.ovh/imgs/2021/09/a972d7c8ae87ce20.webp" alt="Linux系统日志体系"></p>
<p>用户进程通过调用syslog函数生成系统日志，该函数将日志输出到一个UNIX本地域socket类型的文件/dev/log中，rsyslogd则监听该文件以获取用户进程的输出。</p>
<p>内核日志用printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中，rsyslogd通过读取该文件获得内核日志。</p>
<h4 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h4><p>应用程序使用<code>syslog</code>函数与rsyslogd守护进程通信，函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *message, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数采用可变参数来结构化输出。</p>
<p><code>priority</code>参数是所谓的设施值与日志级别的按位或。设施值的默认值为<code>LOG_USER</code>，之后的讨论也只限于这一种设施值。日志级别有如下几个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_EMERG       0       <span class="comment">/* 系统不可用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ALERT       1       <span class="comment">/* 报警，需要立即采取动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CRIT        2       <span class="comment">/* 非常严重的情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERR         3       <span class="comment">/* 错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARNING     4       <span class="comment">/* 警告 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NOTICE      5       <span class="comment">/* 通知 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO        6       <span class="comment">/* 信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG       7       <span class="comment">/* 调试 */</span></span></span><br></pre></td></tr></table></figure>

<p>下面的函数可以改变syslog的默认输出方式，进一个结构化日志内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> logopt, <span class="keyword">int</span> facility)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>ident</em></strong>参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。</p>
<p><strong><em>logopt</em></strong>参数对后续<code>syslog</code>调用的行为进行配置，它可以去下列值的按位或：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PID        0x01      <span class="comment">/* 在日志消息中包含程序PID */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CONS       0x02      <span class="comment">/* 如果消息不能记录到日志文件，则打印至终端 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ODELAY     0x04      <span class="comment">/* 延迟打开日志功能直到第一次调用syslog */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NDELAY     0x08      <span class="comment">/* 不延迟打开日志功能 */</span></span></span><br></pre></td></tr></table></figure>

<p><strong><em>facility</em></strong>参数可用来修改syslog函数中的默认设施值。</p>
<p>此外，日志的过滤也很重要。程序开发阶段可能需要输出很多调试信息，而发布之后我们有需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布前删除代码，而是简单地设置<strong>日志掩码</strong>。使日志级别大于日志掩码的日志信息被系统忽略：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>maskpri</em></strong>参数指定日志掩码值。该函数始终成功，并返回调用进程先前的日志掩码值。</p>
<p>最后，可使用如下函数关闭日志功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="声明（2021-9-23）"><a href="#声明（2021-9-23）" class="headerlink" title="声明（2021.9.23）"></a>声明（2021.9.23）</h4><blockquote>
<p>这篇博客至此，已经3w多字了，每天的阅读进度只有2页左右，却花费了很多的时间。这些时间大多花在博客上，本来的想法是把书中重点，以及自己的心得记录一下，却不知不觉地成了几乎是文章的复制，效率很低，尤其现在事情多了起来，完完全全把书抄一遍在博客上显然是不可取的。这本书说实话，大篇幅都是函数指南，而系统底层本质说的很少，所以在这本书上耗费过多的时间不值得。于是，接下来的记录会尽量精简。</p>
</blockquote>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h4><p>解释：UID（真实用户ID），EUID（有效用户ID），GID（真实组ID），EGID（有效组ID）</p>
<p>在#include&lt;sys/types.h&gt;和#include&lt;unistd.h&gt;头文件下有<strong>一组set/get方法</strong>以设置/获取这些信息。</p>
<p>一个进程拥有两个用户ID：UID和EUID。EUID存在的目的是方便资源访问：<strong>它使得运行程序的用户拥有该程序的有效用户的权限</strong>。例如，普通用户访问su程序，实际上其有效用户ID为root的ID。</p>
<p>文件可以设置<code>set-user-id</code>标志，这样的话，<strong>任何普通用户运行该程序时，其有效用户都是文件的所有者</strong>。</p>
<p>下面可以测试UID和EUID的区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="keyword">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"userid is %d, effective userid is %d\n"</span>,uid, euid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译该文件，得到可执行文件（名为test_uid），将其所有者设置为root，并设置该文件的set-user-id标志，然后运行程序查看UID和EUID。具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root: root test_uid    <span class="comment"># 修改目标文件的所有者为root</span></span><br><span class="line">$ sudo chmod +s test_uid            <span class="comment"># 设置目标文件set-user-id标志</span></span><br><span class="line">$ ./test_uid</span><br><span class="line">userif is 1000, effetctive userid is 0</span><br></pre></td></tr></table></figure>

<p>从输出来看，该进程的UID是启动程序的用户ID，而EUID则是root用户（文件所有者）的ID。</p>
<h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>Linux下每个进程都隶属于一个进程组，每个进程组都有一个首领进程，其PID与PGID相等，我们可以获取/设置指定进程的进程组ID（PGID）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getgpid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setgpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> gpid)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>getgpid</code>获得当前进程的进程组ID，失败返回-1并设置errno。</p>
<p><code>setgpid</code>为进程号为pid的进程（pid为0，表示当前进程）设置进程组ID。成功返回0，失败返回-1并设置errno。</p>
<p>一个进程只能设置自己或者子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>一些有关联的进程组将形成一个会话（session），我们可以创建/获取会话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>setsid</code>不能由进程组的首领进程调用，否则将产生错误。对于非组首领的进程，该函数创建会话，并有如下额外效果：</p>
<ul>
<li>调用进程称为会话的首领，也是新会话的唯一成员</li>
<li>新建一个进程组，其PGID就是调用进程的PID，调用进程称为该组的首领</li>
<li>调用进程将甩开终端（如果存在）</li>
</ul>
<p><code>setsid</code>调用成功返回新进程组的PGID，失败则返回-1并设置errno。</p>
<p><code>getsid</code>调用成功返回当前进程所处的会话ID，失败则返回-1并设置errno。</p>
<h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>使用<code>ps</code>命令可以查看进程、进程组和会话之间的关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgid,sid,comm | less</span><br><span class="line">PID   PPID   PGID   SID   COMMAND</span><br><span class="line">1943  1942   1943   1943   bash</span><br><span class="line">2298  1943   2298   1943   ps</span><br><span class="line">2299  1943   2298   1943   less</span><br></pre></td></tr></table></figure>

<p>可以看出，ps和less命令的父进程是bash命令（PPID），3条命令创建了一个会话（SID: 1943）和两个进程组（PGID分别为1943和2298）。bash是会话的首领，ps命令是进程组2298的首领。</p>
<h3 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h3><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制（CPU数量、内存数量等）、系统策略限制（CPU时间等）、以及具体实现的限制（文件名最大长度等）。可以通过如下一对函数来读取和设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>

<p>rlim参数是rlimit结构体类型的指针，其结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>rlim_t</code>是一个整数类型，它描述资源级别。<code>rlim_cur</code>指定资源的软限制（最好不要超过），<code>rlim_max</code>指定资源的硬限制（软限制的上限）。</p>
<p><code>setrlimit</code>和<code>getrlimit</code>成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。</p>
<h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><p>有些服务器程序需要改变工作目录和根目录。如Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录（一般是/var/www/），可以获取进程当前工作目录和改变进程工作目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>getcwd</code>成功时返回一个指向目标存储区（buf指向的存储区或是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设置errno。若内部动态创建，则需要手动释放内存。</p>
<p>还可以改变进程的根目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>path</em></strong>参数指定要切换到的目标根目录。它成功时返回<code>0</code>，失败则返回<code>-1</code>并设置errno。</p>
<p><code>chroot</code>并不改变进程的当前工作目录，所以调用chroot后，仍然需要使用<code>chdir(&quot;/&quot;)</code>来将工作目录切换到新的根目录。</p>
<h3 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h3><p>如何在代码中让一个进程以守护进程的方式运行？守护进程的编写遵循一定的步骤，下面通过一个具体实现来探讨：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">/* 创建子进程，关闭父进程，这样可以使程序在后台运行 */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置文件权限掩码 */</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新的会话，设置本进程为进程组的首领 */</span></span><br><span class="line">    <span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line">    <span class="keyword">if</span>(sid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 切换工作目录 */</span></span><br><span class="line">    <span class="keyword">if</span>( (chdir(<span class="string">"/"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭标准输入/出设备，标准错误输出设备 */</span></span><br><span class="line">    <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">close</span>(STDERR_FILENO):</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭其他已经打开的文件描述符，代码略 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将标准输入，标准输出和标准错误输出都定向到/dev/null文件 */</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，Linux提供了完成同样功能的库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>nochdir</code>指定是否改变工作目录，若传递0，则工作目录被设置为“/”，否则继续使用当前工作目录。</p>
<p><code>noclose</code>参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件中，否则依然使用原来的设备。</p>
<p>该函数成功时返回<code>0</code>，失败时返回<code>-1</code>并设置errno。</p>
<h2 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h2><p>暂略，目前看不懂    ——9.24</p>
<h1 id="Ex-问题记录"><a href="#Ex-问题记录" class="headerlink" title="Ex:问题记录"></a>Ex:问题记录</h1><ul>
<li><p>自己的Ubuntu虚拟机连不上网？</p>
<p>先用ifconfig查看网卡接口是启动，而ifconfig -a 可以查看所有的网卡接口。若ifconfig没有出现对应的网卡接口，可以执行 <code>dhclient &lt;网卡名称&gt;</code> 来动态获取IP地址，以恢复网络连接。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://aliez22.github.io/posts/25569/">https://aliez22.github.io/posts/25569/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://aliez22.github.io" target="_blank">zzm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/041.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/21369/"><img class="prev-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/023.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">小新pro14更新windows后的问题-关机后自动重启</div></div></a></div><div class="next-post pull-right"><a href="/posts/64385/"><img class="next-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog@latest/pixiv/021.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Github疑难杂症</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/44682/" title="【Linux】编写一个内核模块"><img class="relatedPosts_cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/016.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="relatedPosts_title">【Linux】编写一个内核模块</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> zzm</div><div class="framework-info"><span> &gt;明确目标 不留余力&lt; </span></div></div><head><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script></body></html>