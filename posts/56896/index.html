<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ primer(第五版) 要点记录 | zzm</title><meta name="description" content="这段时间又刷了一遍C++ Primer (第五版)，把之前尚未完全理解以及重要内容记录在本文中。 一些概要 C++之所以脱离C而存在，还是因为其强大的抽象能力。C++同时支持4中不同的编程风格：C风格、基于对象、面向对象和泛型。  利用无符号数来写循环，很可能不经意间就会出现死循环。   C++基础 区分初始化和赋值，尤其是用“&#x3D;”号来进行初始化的情况。 初始化： C++新标准中，用花括号的形式进"><meta name="keywords" content="C++"><meta name="author" content="zzm"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://aliez22.github.io/posts/56896/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//fastly.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="C++ primer(第五版) 要点记录"><meta property="og:url" content="https://aliez22.github.io/posts/56896/"><meta property="og:site_name" content="zzm"><meta property="og:description" content="这段时间又刷了一遍C++ Primer (第五版)，把之前尚未完全理解以及重要内容记录在本文中。 一些概要 C++之所以脱离C而存在，还是因为其强大的抽象能力。C++同时支持4中不同的编程风格：C风格、基于对象、面向对象和泛型。  利用无符号数来写循环，很可能不经意间就会出现死循环。   C++基础 区分初始化和赋值，尤其是用“&#x3D;”号来进行初始化的情况。 初始化： C++新标准中，用花括号的形式进"><meta property="og:image" content="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/033.webp"><meta property="article:published_time" content="2022-06-26T01:38:14.000Z"><meta property="article:modified_time" content="2022-07-20T04:00:40.878Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="【算法系列二】链表" href="https://aliez22.github.io/posts/34375/"><link rel="next" title="【开源项目】为openEuler5.10内核增添页表检查功能" href="https://aliez22.github.io/posts/23548/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-07-20 12:00:40'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一些概要"><span class="toc-number">1.</span> <span class="toc-text">一些概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-基础"><span class="toc-number">2.</span> <span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-标准库"><span class="toc-number">3.</span> <span class="toc-text">C++标准库</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/033.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">zzm</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++ primer(第五版) 要点记录</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-06-26 09:38:14"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-06-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-07-20 12:00:40"><i class="fas fa-history fa-fw"></i> 更新于 2022-07-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>这段时间又刷了一遍C++ Primer (第五版)，把之前尚未完全理解以及重要内容记录在本文中。</p>
<h2 id="一些概要"><a href="#一些概要" class="headerlink" title="一些概要"></a>一些概要</h2><ul>
<li><p>C++之所以脱离C而存在，还是因为其强大的抽象能力。C++同时支持4中不同的编程风格：C风格、基于对象、面向对象和泛型。</p>
</li>
<li><p>利用无符号数来写循环，很可能不经意间就会出现死循环。</p>
</li>
</ul>
<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><ul>
<li><p>区分<strong>初始化</strong>和<strong>赋值</strong>，尤其是用“=”号来进行初始化的情况。</p>
<p>初始化：</p>
<p>C++新标准中，用花括号的形式进行“列表初始化”得到了全面应用。但当用于内置变量时，这种初始化有一个重要特点：如果使用列表初始化，且初始值存在丢失信息的风险，则编译器将报错：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b=&#123;ld&#125;;          <span class="comment">// 错误：存在信息丢失的风险，double-&gt;int</span></span><br><span class="line">int c(ld), d=ld;            // 正确：因为用非列表初始化的形式进行初始化</span><br></pre></td></tr></table></figure>

<p>若定义变量时没有指定初值，将被<em>默认初始化</em>，变量被赋予“默认值”：定义于任何函数体之外的变量被初始化为0，而<em>定义在函数体内部的内置数据变量将不被初始化</em>，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>在新标准下，现在C++程序最好使用<code>nullptr</code>为指针类型初始化空指针，同时尽量避免使用NULL。</p>
</li>
<li><p>分离式编译机制：允许将程序分割为若干个文件，每个文件可以被独立编译。</p>
<p>C++将<strong>声明（declaration）</strong>和<strong>定义（definition）</strong>区分开，声明使名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明；定义则负责创建与名字关联的实体。</p>
<p>要声明一个变量而非定义，就在变量名前添加关键字<code>extern</code>，而且不要显式地初始化变量。</p>
<p>不过注意，在函数体内部初始化一个由extern关键字标记的变量，将引发错误。函数体内可以声明并使用extern变量，但是去初始化/定义它，那么在离开函数体后改变量的作用域就失效了，所以会引发错误。</p>
</li>
<li><p>const关键字：</p>
<p><strong>const引用</strong>：引用的类型必须与其所引用对象的类型一致，且不能为非常量引用绑定字面值，但有两个例外：（1）在初始化常量引用时允许用任意表达式作为初始值，只要该表达式结果能够转换成引用的类型即可；（2）对const的引用可能引用一个非const的对象。</p>
<p>注意，const引用仅限制了对引用的操作（不能修改所引用的值，注意，引用本身就是从一而终的，只能在定义时初始化一次，后面不可改变而引用其他变量），但并未限制所引用的对象是否为常量。</p>
<p><strong>const指针</strong>：分为（1）指向常量的指针：不能改变所指向对象的值；（2）常量指针：不能改变指针的指向。指向常量的指针并没有规定所指对象是否一定为常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;            <span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="keyword">double</span> *<span class="keyword">const</span> cp = &amp;pi;              <span class="comment">// 常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;       <span class="comment">// 指向常量的常量指针</span></span><br></pre></td></tr></table></figure>

<p>这里其实可以抽象出两个独立的问题，即<code>顶层const</code>：表示指针/基本类型<strong>本身</strong>是一个常量，和<code>底层const</code>：表示指针<strong>所指的对象</strong>是一个常量。C++11中的constexpr会将所定义的对象置为顶层const。</p>
<p>区分 顶层const 和 底层const 很重要。</p>
</li>
<li><p>处理类型</p>
<p><strong>类型别名</strong>：有两种方法定义类型别名，（1）传统的typedef，（2）新标准中的<em>别名声明</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> base, *p;           <span class="comment">// typedef定义类型别名，base是double同义词，p是double*同义词</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;              <span class="comment">// using别名声明</span></span><br></pre></td></tr></table></figure>

<p><strong>auto类型说明符</strong>：C++11新标准引入auto，能让编译器替我们分析表达式所属的类型，显然auto定义的变量必须有初始值。其次，<em>auto一般会忽略顶层const，而保留底层const</em>，如果希望推断出auto类型为顶层const需要显示指出“<code>const auto ...</code>”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;           <span class="comment">// b是个整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;           <span class="comment">// c是个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;           <span class="comment">// d是个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;          <span class="comment">// e是一个指向整数常量的指针</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype类型指示符</strong>：C++11新标准引入decltype，能够不调用操作而选择操作返回的数据类型。</p>
<p>decltype与auto的不同：（1）如果decltype使用的表达式是一个变量，那么返回该变量的类型（包括顶层const和引用）；（2）decltype的结果类型与表达式形式密切相关，如果给变量加上了一层或多层括号，这样就会得到引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;       <span class="comment">// sum的数据类型就是函数f返回的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;          <span class="comment">// x类型为const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;          <span class="comment">// y类型为const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;              <span class="comment">// 错误，z是const int&amp; 类型，必须初始化！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;             <span class="comment">// 错误，d是int&amp; 类型，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;               <span class="comment">// e是int类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>头文件</p>
<p><strong>预处理器</strong>（preprocessor）常用来确保头文件多次包含仍能安全工作。包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> xxx_H             <span class="comment">// 当且仅当变量未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxx_H             <span class="comment">// 把一个名字设定为预定义变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;          // 头文件替代</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                    <span class="comment">// 结束预处理命令</span></span></span><br></pre></td></tr></table></figure>

<p>头文件中一般不包含using 声明命名空间。</p>
</li>
<li><p>标准库类型：string</p>
<p><code>string</code>表示<em>可变长</em>的字符序列，包含在头文件string中。初始化有如下几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;              <span class="comment">// 默认初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;          <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;     <span class="comment">// s3是字面值“value”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;      <span class="comment">// s4初始化为连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure>

<p>string.size()返回<strong>size_type</strong>类型，略微复杂，但可以理解为一个unsigned类型的整数，可以用<code>auto</code>或<code>decltype</code>来推其类型。</p>
<p>可以用字面值常量与string相加，但是两个字面值不能相加。</p>
<p>若要单独处理string中的字符，可以利用cctype头文件中定义的标准库函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)                 c是字母或数字时为真</span><br><span class="line">isalpha(c)                 c是字母时为真</span><br><span class="line">isidigit(c)                c是数字时为真</span><br><span class="line">tolower(c)                 转换为小写</span><br><span class="line">toupper(c)                 转换为大写</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以使用<strong>范围for语句</strong>（C++新标准）来处理string中的每个字符，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库类型：vector</p>
<p>vector模板定义和初始化的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1;             <span class="comment">// v1是一个空的vector，元素类型为T，默认初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;         <span class="comment">// v2中包含v1所有元素的副本</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v3</span><span class="params">(n)</span></span>;          <span class="comment">// v3包含了n个元素，每个元素的值默认初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v4</span><span class="params">(n, val)</span></span>;     <span class="comment">// v4包含了n个元素，每个元素的值为val</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5&#123;a,b,c..&#125;;    <span class="comment">// v5初始化为a,b,c.. 注意，列表初始化要用大括号而不是圆括号</span></span><br></pre></td></tr></table></figure>

<p>注意，圆括号和大括号，圆括号用来<strong>构建vector对象</strong>，而大括号用来进行<strong>列表初始化</strong>。</p>
<p>运行时向vector添加成员：push_back，向尾端（back）添加元素。</p>
<blockquote>
<p>思考：vector能够高效增长，那么vector是如何提升动态添加元素的性能的呢？（暂时先留着这个问题）</p>
</blockquote>
<p>vector使用时的一些编程假定：</p>
<ul>
<li>如果循环内包含有向vector对象添加元素的语句，那么就不能使用范围for循环。</li>
<li>只能对已存在的元素执行下标操作，若vector为空是不能执行下标操作的。</li>
</ul>
</li>
</ul>
<ul>
<li><p>迭代器</p>
<p>容器类型一般都有迭代器，能够提供对于对象的间接访问。迭代器由名为<strong>begin</strong>和<strong>end</strong>的成员函数获得。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = vec.<span class="built_in">begin</span>(), e = vec.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>

<p><code>b</code>表示vec的<strong>第一个元素</strong>，而<code>e</code>表示vec<strong>尾元素的下一个位置</strong>，这是容器的一个本不存在的“尾后”元素，没有实际意义，仅是一个标记。注意，如果容器为空，那么begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<p>迭代器使用 == 和 != 来判断两个迭代器是否相等，支持++，– , +/- 整数，以及迭代器之间的减法操作；使用解引用 * 可以获得迭代器所指对象的引用。const_iterator类型是只读迭代器。</p>
<blockquote>
<p><strong>某些对vector对象的操作会使迭代器失效！</strong></p>
<p>vector的动态增长会带来一些副作用：</p>
<p>1，不能在范围for循环中向vector对象添加元素；</p>
<p>2，任何一种可能改变vector对象容量的操作（如push_back），都会使vector对象的迭代器失效。【315页详细说明迭代器如何失效的】</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>数组</p>
<p>定义数组时，必须指定数组的类型（不能用auto来根据初始值列表判断类型）和长度（数组大小必须是常量表达式）。且数组元素必须是对象，故不会存在引用的数组。</p>
<p>数组与vector存在一定的差异，体现在如下方面：</p>
<ul>
<li>字符数组：用字符串字面值来为字符数组初始化时，字符串的末端会有一个空字符，字符数组的长度应该为字符串长度+1。</li>
<li>不允许利用一个数组为另一个数组赋值，以及初始化。</li>
</ul>
<p>数组与指针有紧密联系，<strong>在使用数组的时候，编译器一般会把它转化成指针</strong>。这一结论有很多隐含意义：</p>
<ol>
<li><p>用到数组名字的地方，编译器都会自动将其替换为一个指向数组首元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p2 = nums;          <span class="comment">// 等价于 string *p2 = &amp;nums[0];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数组作为一个auto变量的初始值时，推断得到的类型是指针而不是数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> ia2 = ia;        <span class="comment">// ia2 是一个整型指针，指向ia的第一个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针也可以作为迭代器，但是要知道头指针和尾后指针的位置，可以用标准库函数begin和end来获得。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>* curr = <span class="built_in">begin</span>(ia); curr!=last; curr++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*curr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>多维数组：当使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;     <span class="comment">// p是一个指针，指向含4个int的数组，圆括号不能省略</span></span><br><span class="line">  <span class="keyword">int</span> *p[<span class="number">4</span>];            <span class="comment">// p时一个含4个int*类型的数组</span></span><br></pre></td></tr></table></figure>

<p>写不写圆括号经常会引发问题，C++11新标准中，可以通过使用auto或者decltype来避免这样复杂的写法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p != ia+<span class="number">3</span>; ++p)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q != *p+<span class="number">4</span>; ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步地，结合标准库的begin和end，能够使代码更加简洁。</p>
</li>
<li><p>运算符与类型</p>
<p>对于自增、自减运算符，除非必要，尽量避免使用后置版本。因为后置版本需要将原始值存储下来，如果我们不需要修改前的值，那么这就是一种浪费。</p>
<p>注意运算符的优先顺序。</p>
<p>成员运算符 p-&gt;item 等价于 (*p).item。</p>
<p><strong>显示的强制类型转换</strong>：<code>cast-name&lt;type&gt;(expression);</code></p>
<ul>
<li><p>type是转换的目标类型</p>
</li>
<li><p>cast-name为 static_cast、dynami_cast、const_cast 和 reinterpret_cast 中的一种；dynamic_cast 支持运行时类型识别，将在730页做更详细的介绍。</p>
<blockquote>
<p>static_cast: 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p>
<p>可用于，执行浮点数除法；将较大类型赋值给较小类型；找回void*指针中的值 等等。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>const_cast只能改变运算对象的底层const，不能改变表达式的类型，将常量对象转化为非常量对象。</p>
<p>常常用于有函数重载的上下文中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);     </span><br><span class="line"><span class="comment">// 这是可以的，但是通过p写值是未定义的行为：如果pc指向的常量值，那么将引发错误；如果pc指向的不是常量，那获得写权限是合法的。</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(pc);     <span class="comment">// 可以，将字符串字面值转化为string</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(pc);      <span class="comment">// 错误，const_cast不能改变表达式的类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。</p>
<p>比如将 int指针 强制转换成 char指针，但是这样是很危险的，改变了类型但是编译器没有警告或者错误，就很可能在运行时发生错误。</p>
<p>reinterpret_cast本质上依赖于机器，要安全使用就必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
</blockquote>
<p>建议还是避免强制类型转换！</p>
</li>
</ul>
</li>
<li><p>函数</p>
<p>将只存在于块执行期间的对象称为<strong>自动对象</strong>，当块的执行结束后，块中创建的自动对象的值就变成未定义的了。形参和局部变量都是自动对象。</p>
<p><strong>局部静态对象</strong>：将局部变量定义为static，它在第一次定义语句时初始化，作用域在块中，生命周期一直到程序终止。例如，在函数中定义局部静态对象来统计函数被调用的总次数。</p>
<p><strong>参数传递</strong>：形参初始化的机理与变量初始化一样。</p>
<ul>
<li><p>形参是引用类型时，它对应的实参被<strong>引用传递</strong>。引用形参其实跟引用一样，在其上的操作实际是作用在所引用的对象上。使用引用形参：</p>
<p>（1）能够<strong>避免实参的拷贝</strong>（若不允许实参改变，可以加const），尤其是某种类型不支持拷贝操作时，函数就只能通过引用形参来访问。</p>
<p>关于形参const：与其他初始化一样，用实参初始化形参时会忽略顶层const（实参是const引用或者底层const，那么形参肯定也要加const），也就是说，形参为const类型，但是实参既可以传const也可以传非const。所以，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数不能一起定义，因为他们形参实际上没有什么不同，接受的实参类型一样。</p>
<p>总的来说，若实参不能改变，那么形参也不能在函数中改变实参。即：（1）若形参是对象类型，那么初始化形参相当于创建了实参的副本，肯定不会改变实参；（2）若形参是引用或者指针类型，那么若形参不加const，就有可能改变实参，这样就不对了。</p>
<p>建议：<strong>尽量使用常量引用，可以避免实参被改变，也扩展了函数所能接受的实参类型</strong>。</p>
<p>（2）能够<strong>返回额外信息</strong>，一个函数只能返回一个值，引用形参为一次返回多个结果提供了途径。</p>
</li>
<li><p>实参的值拷贝给形参时，形参和实参是两个独立的对象（形参不会改变实参），此时实参被<strong>值传递</strong>。</p>
<blockquote>
<p>注意，指针形参的行为与其他非引用类型一样，执行指针拷贝操作，拷贝的是指针的值，但是形参和实参是不同的指针，只是指向的地址相同，所以可以间接地访问所指对象。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>  <strong>数组形参</strong></p>
<p>  数组具备两个特性：（1）不允许拷贝数组；（2）使用数组时（通常）会将其转换成指针。</p>
<p>  数组以指针的形式传递给函数，所以一开始函数并不知道数组的确切尺寸。有时候往往需要传递额外的信息表示数组的大小。</p>
<p>  传递多维数组：将多维数组 <code>arr[m][n]</code> 传递给函数时，真正传递的是指向数组首元素的指针 ( <code>int (*p)[n]</code> )，所以第二维在形参中是不可省略的。p 两端的括号也不可省！</p>
<p>  <strong>返回值</strong></p>
<p>  返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，这个临时量就是函数调用。</p>
<p>  （1）不要返回局部对象的引用或者指针：函数完成，它所占用的存储空间也随之释放，引用局部遍历的引用将指向不再有效的内存区域。</p>
<p>  （2）返回类型为引用，将会返回左值。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">    get_val(s, <span class="number">0</span>) = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 输出 A value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>函数重载</strong></p>
<p>  在同一作用域内的几个函数<em>名字相同但形参列表不同</em>，就称之为<strong>重载（overloaded）</strong>函数。当调用这些函数时，编译器会根据传递的实参类型判断想要的是哪个函数。</p>
<p>  对于重载的函数，它们应该在 形参数量 或者 可接受的实参类型或者顺序 上有所不同。</p>
<blockquote>
<p>需要注意的是，一个拥有顶层const的形参无法与另一个没有顶层const的形参区分开。</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;       <span class="comment">// 重复声明，对象形参不会改变实参，都可以接受const或非const实参</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;      <span class="comment">// 重复声明，这是指针本身const，顶层const形参，无效</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;    <span class="comment">// 正确，作用于const引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;    <span class="comment">// 正确，这是指向const的指针，底层const</span></span><br></pre></td></tr></table></figure>

<p>  对于引用形参而言，若不需要在函数中修改它，建议使用const引用形参，这样可以扩展实参的范围也可以更安全。但如果返回值还是原来对象的引用的话，就只能返回const引用了；如果实参是非const的引用，但是返回了const引用，那么就无法对返回结果进行修改了。这种情况可以通过const_cast来解决：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很好，唯一缺点就是若实参是非const引用，但是返回了const引用，无法对结果修改</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于以上问题，利用const_cast重载这个函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterStr</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;r = shorterStr(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>想法：如果这个函数返回bool值，那么两个函数返回类型一致【1】，第一个函数形参支持const和非const，第二个仅支持非const，这样传非const会调用哪个函数？是不是会发生问题？</p>
<p>==&gt; 这样重载不会发生问题，优先调用形参为非const的函数。</p>
<p>【1 后期思考】：其实这里也有思维bug，返回值类型不影响函数重载！</p>
</blockquote>
<p>  重载确定：编译器将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底用哪个函数。这可能导致三种结果：</p>
<ul>
<li><p>编译器找到一个与实参<strong>最佳匹配</strong>的函数，并调用该函数的代码。</p>
</li>
<li><p>找不到任何一个函数与调用的实参匹配，编译器发出<strong>无匹配</strong>的错误信息。</p>
</li>
<li><p>有多于一个函数可以匹配，但每一个都不是明显的最佳选择，将发生<strong>二义性调用</strong>。</p>
<p>重载函数拥有共同的名字，这个名字也遵循作用域的相关原则（如，隐藏作用域）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">// print名字进入了新的作用域，隐藏前面出现的print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Value "</span>);        <span class="comment">// 错误，fooBar之前的print名字被隐藏</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);            <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <strong>内联函数</strong></p>
<p>  调用函数一般比求等价表达式的值要慢一些，因为一次函数调用包含着一系列的工作：调用前先保存寄存器，在返回时恢复，可能拷贝实参等。</p>
<p>  将函数指定为内联函数，就是会将函数在每个调用点上“内联地”展开。例如把之前的 shorterStr 定义为内联(inline)，那么将产生这样的效果：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; shorterStr(s1,s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 在编译过程中展开类似于下面的形式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>  一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数，很多编译器不支持内联递归函数。通常定义在头文件中。</p>
<ul>
<li><p>类</p>
<p><em>定义</em>在类内部的函数是隐式inline函数。（？？）</p>
<p>类的成员函数可以使用 this 隐式参数来访问调用它的那个对象，当调用成员函数时，会用请求该函数对象地址初始化this。因为this总是指向“这个”对象，所以它是一个常量指针。</p>
<p>可以在函数圆括号后加上const来构成 常量成员函数：常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
<p>类中成员与函数的顺序无需在意，编译器会首先编译成员的声明，然后才轮到成员函数体。</p>
<p><strong>构造函数</strong></p>
<p>C++11新标准中，如果需要默认的构造行为，可以在参数列表后面写上 <code>= default</code> 来告诉编译器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;       <span class="comment">// 默认构造</span></span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s):bookNo(s)&#123;&#125;   <span class="comment">// 初始值列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：构造函数初始值列表只说明用于初始化的值，而不限定初始化的具体执行顺序！成员的初始化顺序与它们在类定义中的出现顺序一致。</p>
<p>class 与 struct 的默认访问权限不同，class默认为private，而struct默认为public。</p>
<p>类可以允许其他类或者函数访问它的非公有成员，方法是让其他类或者函数成为它的友元，在类中用friend关键字来声明函数。</p>
<p><strong>静态成员</strong></p>
<p>类的静态成员存在于任何对象之外，对象中不包含任何于静态数据成员有关的数据。静态数据成员被所有该类对象共享，静态成员函数也不与任何对象绑定在一起，它们不含this指针。</p>
<p>静态成员函数可以在类内和类外定义，当在类外定义时，不能重复static关键字。）。</p>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h2><ul>
<li><p>IO库</p>
<p>标准库定义了一些IO类型，分别在三个独立的头文件中：<strong>iostream</strong> 定义了用于读写流的基本类型， <strong>fstream</strong> 定义了读写命名文件的类型， <strong>sstream</strong> 定义了读写内存string对象的类型。同时也支持宽字符的语言（如 wcin 对应 cin 宽字符版对象）。</p>
<p>下面介绍标准库流的特性，这些流特性可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本：</p>
<ul>
<li><p>IO对象无拷贝或赋值</p>
<p>不能拷贝IO对象，故不能将形参或返回类型设置为流类型。读写一个IO对象会改变其状态，因此传递和返回的引用不能为const。</p>
</li>
<li><p>流存在条件状态</p>
<p>IO操作可能发生错误，标准库定义了一些函数和标志，来访问和操纵流的条件状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strm::iostate           strm是一种IO类型，这是与机器无关的类型</span><br><span class="line">strm::badbit            指出流已崩溃</span><br><span class="line">strm::failbit           指出一个IO操作失败了</span><br><span class="line">strm::eofbit            指出流到达了文件结束</span><br><span class="line">strm::goodbit           指出流未处于错误状态，此值为0，表示未发生错误</span><br><span class="line">s.clear()               将流s中所有条件状态位复位，流状态设置为有效</span><br><span class="line">s.rdstate()             返回流s的当前条件状态，返回类型为strm::iostate</span><br><span class="line">s.setstate(flags)       根据给定flags标志位，将流s中对应的条件状态位置位，flags类型为strm::iostate</span><br></pre></td></tr></table></figure>

<p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象最简单的方法就是将它作为一个条件来使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    <span class="comment">// ok: 读操作成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出缓冲</p>
<p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。缓冲机制可以让操作系统将程序的多个输出操作组合成单一的系统级写操作。</p>
<p>能够刷新缓冲（数据真正写道输出设备或文件）的原因有：</p>
<ul>
<li>程序正常结束</li>
<li>缓冲区满时</li>
<li>使用操纵符如 endl 来显式刷新缓冲区（flush也可以，且不附加额外字符）</li>
<li>每个输出操作后，可以用操纵符unitbuf设置流内部状态，来清空缓冲区</li>
<li>一个输出流被关联到另一个流，则关联到的流的缓冲区会被刷新（可以将一个istream对象关联到另一个ostream对象，也可以将一个ostream关联到另一个ostream，用tie函数）</li>
</ul>
</li>
</ul>
</li>
<li><p>顺序容器</p>
<p>顺序容器提供了控制元素存储和访问顺序的能力。顺序不依赖元素的值，而与元素加入容器时的位置相对应。</p>
<table>
<thead>
<tr>
<th>容器类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>可变大小数组。支持快速随机访问，在尾部之外的地方插入或删除元素较慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列。支持快速随机访问，在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表。只支持双向顺序访问，在链表任何位置进行插入/删除都很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单项顺序访问，在链表任何位置进行插入/删除都很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组。支持快速随机访问，不能添加或删除元素，只能进行覆盖</td>
</tr>
<tr>
<td>string</td>
<td>与vector类型，但专用于保存字符，随机访问快，在尾部插入/删除快</td>
</tr>
</tbody></table>
<p><strong>swap操作</strong></p>
<p>容器提供swap操作，交换两个相同类型容器中的内容，速度比拷贝快得多。（亿数量级别的整形vector，用拷贝的方式交换要399ms，而swap耗时0ms）</p>
<p>除array外，交换两个容器内容的操作保证会很快，因为元素本省并没交换，swap只是交换了两个容器的内部数据结构，能在<strong>常数时间内完成</strong>。swap有两个特例：</p>
<ul>
<li>对一个string调用swap会导致迭代器、引用和指针失效；</li>
<li>对array进行swap操作，指针、引用和迭代器所绑定的元素不变，但是会真正交换元素，所需时间与array中的元素数目成正比。</li>
</ul>
<p>在新标准库中，容器既提供成员函数版本的swap，也提供非成员函数版本的swap，统一使用非成员函数版本的swap是一个好习惯。</p>
<p><strong>向顺序容器添加元素</strong></p>
<p>除array外，所有标准库容器都提供灵活的内存管理，可以在运行时动态添加或删除元素来改变容器大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些操作会改变容器大小（array不支持）</span></span><br><span class="line">c.push_back(t);</span><br><span class="line">c.emplace_back(args);         <span class="comment">// 在c尾部创建一个值为t或由args创建的元素，返回void</span></span><br><span class="line"></span><br><span class="line">c.push_front(t);</span><br><span class="line">c.emplace_front(args);        <span class="comment">// 在c头部创建一个值为t或由args创建的元素，返回void</span></span><br><span class="line"></span><br><span class="line">c.insert(p, t);</span><br><span class="line">c.emplace(p, args);           <span class="comment">// 在迭代器p指向元素前创建一个值为t或由args创建的元素，返回新添元素迭代器</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>forward_list有自己专有版本的 insert 和 emplace</li>
<li>forward_list不支持 push_back 和 emplace_back</li>
<li>vector和string不支持 push_front 和 emplace_front，但支持insert来实现头部插入</li>
</ul>
<blockquote>
<p>关键概念</p>
<p>当用一个对象来初始化容器时，或者将一个对象插入到容器中，实际上放入到容器中的对象值是一个拷贝，而不是对象本身，这类似于将对象传入一个非引用参数。</p>
</blockquote>
<p>可以使用insert来向指定位置插入元素，同时，利用insert的返回值，能够在容器特定位置反复插入元素。</p>
<p>新标准引入三个新成员：emplace_front、emplace 和 emplace_back，这些操作构造，而不是拷贝元素。</p>
<blockquote>
<p>push_* 与 emplace_* 的区别在于，push系列函数会构造临时对象，再将这个对象拷贝到容器末尾，而emplace系列函数则直接在容器末尾构造对象，省去了拷贝的过程，会更高效一些。</p>
</blockquote>
<p>调用 push 或 insert 时，要求传递对应类型的对象，这些对象被拷贝到容器中；而当调用 emplace 时，则将参数传递给对象的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在c末尾添加一个Sales_data对象</span></span><br><span class="line"><span class="comment">// 使用三个参数的Sales_data构造函数</span></span><br><span class="line">c.emplace_back(<span class="string">"978-0001"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// 传递Sales_data给push函数</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0001"</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>

<p>emplace函数在容器中直接构造元素对象，所以传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p>
<p><strong>访问元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at和下标操作只适用于string、vector、deque和array</span><br><span class="line">back不适用于forward_list</span><br><span class="line"></span><br><span class="line">c.back()             返回c中尾元素的引用。若c为空，函数行为未定义</span><br><span class="line">c.front()            返回c中首元素的引用。若c为空，函数行为未定义</span><br><span class="line">c[n]                 返回c中下标为n的元素的引用。若n&gt;&#x3D;c.size()则函数行为未定义</span><br><span class="line">c.at(n)              返回下标为n的元素的引用。若下标越界，抛出 out_of_range 异常（比下标操作更安全）</span><br><span class="line"></span><br><span class="line">c.front() 等价于 *(c.begin())</span><br></pre></td></tr></table></figure>

<p>注意，容器中访问元素的成员函数（front, back, 下标和 at）返回的都是<code>引用</code>。如果容器是const对象，那么返回const引用。非const容器返回的引用可以修改，但如果用 auto变量来保存返回值，得到的是一个拷贝（比如返回 int引用，auto就推导出int），并不能修改容器的值，所以auto变量也要注意加引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = c.front();        <span class="comment">// 仅是一个拷贝</span></span><br><span class="line"><span class="keyword">auto</span> &amp;v1 = c.front();      <span class="comment">// 是一个引用</span></span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">删除操作会改变容器大小，故不适用于array</span><br><span class="line">forward_list有特殊版本的erase，且不支持pop_back</span><br><span class="line">vector和string不支持pop_front</span><br><span class="line"></span><br><span class="line">c.pop_back()        删除c中尾元素。若c为空，函数行为未定义</span><br><span class="line">c.pop_front()       删除c中首元素。若c为空，函数行为未定义</span><br><span class="line">c.erase(p)          删除迭代器p所指的元素，返回被删元素之后元素的迭代器</span><br><span class="line">c.erase(b, e)       删除迭代器b和e所指范围内的元素，返回最后指向最后一个被删元素后元素的迭代器</span><br><span class="line">c.clear()           删除c中所有元素</span><br></pre></td></tr></table></figure>

<p>注意，删除deque中除首尾位置之外的任何元素都会是所有迭代器、引用和指针失效；指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://aliez22.github.io/posts/56896/">https://aliez22.github.io/posts/56896/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://aliez22.github.io" target="_blank">zzm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/039.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/34375/"><img class="prev-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/034.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【算法系列二】链表</div></div></a></div><div class="next-post pull-right"><a href="/posts/23548/"><img class="next-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/032.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【开源项目】为openEuler5.10内核增添页表检查功能</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/41157/" title="Effective C++ (第三版)"><img class="relatedPosts_cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/038.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-12</div><div class="relatedPosts_title">Effective C++ (第三版)</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> zzm</div><div class="framework-info"><span> &gt;明确目标 不留余力&lt; </span></div></div><head><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script></body></html>