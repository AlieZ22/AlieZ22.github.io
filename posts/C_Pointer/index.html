<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入理解C指针 | zzm</title><meta name="description" content="认识指针指针和内存理解指针的关键在于理解C程序如何管理内存。归根到底，指针包含的就是内存地址。  C程序在编译后，会以三种形式使用内存：     静态&#x2F;全局内存 静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。  自动内存 这些变量在函数内部声明，并且在函数被调用时才创建。它"><meta name="keywords" content="C指针"><meta name="author" content="zzm"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://aliez22.github.io/posts/C_Pointer/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//fastly.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="深入理解C指针"><meta property="og:url" content="https://aliez22.github.io/posts/C_Pointer/"><meta property="og:site_name" content="zzm"><meta property="og:description" content="认识指针指针和内存理解指针的关键在于理解C程序如何管理内存。归根到底，指针包含的就是内存地址。  C程序在编译后，会以三种形式使用内存：     静态&#x2F;全局内存 静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。  自动内存 这些变量在函数内部声明，并且在函数被调用时才创建。它"><meta property="og:image" content="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/006.webp"><meta property="article:published_time" content="2021-03-07T12:24:36.000Z"><meta property="article:modified_time" content="2022-06-07T12:40:25.998Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="柔性数组" href="https://aliez22.github.io/posts/63938/"><link rel="next" title="dd command" href="https://aliez22.github.io/posts/55373/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-06-07 20:40:25'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars.githubusercontent.com/u/34917442" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识指针"><span class="toc-text">认识指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针和内存"><span class="toc-text">指针和内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针的长度和类型"><span class="toc-text">指针的长度和类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针操作符"><span class="toc-text">指针操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针的常见用法"><span class="toc-text">指针的常见用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C的动态内存管理"><span class="toc-text">C的动态内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态内存分配"><span class="toc-text">动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态内存分配函数"><span class="toc-text">动态内存分配函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用malloc函数"><span class="toc-text">使用malloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用calloc函数"><span class="toc-text">使用calloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用realloc函数"><span class="toc-text">使用realloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变长数组"><span class="toc-text">变长数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用free函数释放内存"><span class="toc-text">用free函数释放内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将已释放的指针赋值为NULL"><span class="toc-text">将已释放的指针赋值为NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重复释放"><span class="toc-text">重复释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迷途指针"><span class="toc-text">迷途指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迷途指针示例"><span class="toc-text">迷途指针示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理迷途指针"><span class="toc-text">处理迷途指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和函数"><span class="toc-text">指针和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序的栈"><span class="toc-text">程序的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序栈"><span class="toc-text">程序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈帧的组织"><span class="toc-text">栈帧的组织</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/006.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">zzm</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">深入理解C指针</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-03-07 20:24:36"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-03-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-06-07 20:40:25"><i class="fas fa-history fa-fw"></i> 更新于 2022-06-07</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="认识指针"><a href="#认识指针" class="headerlink" title="认识指针"></a>认识指针</h2><h3 id="指针和内存"><a href="#指针和内存" class="headerlink" title="指针和内存"></a>指针和内存</h3><p>理解指针的关键在于理解C程序如何管理内存。<u>归根到底，指针包含的就是内存地址</u>。 </p>
<p>C程序在编译后，会以三种形式使用内存：   </p>
<ol>
<li><p>静态/全局内存</p>
<p>静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p>
</li>
<li><p>自动内存</p>
<p>这些变量在函数内部声明，并且在函数被调用时才创建。它们的作用域局限在函数内部，而且生命周期限制在函数执行时间内。</p>
</li>
<li><p>动态内存</p>
<p>内存分配在堆上，可以根据需要释放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。（这是第二章的重点）</p>
</li>
</ol>
<p>指针通常根据所指的数据类型来声明，然而，<u>指针本身并没有包含所引用数据的类型信息</u>，指针只包含地址。</p>
<p>*可以将变量声明为指针，这是个重载过的符号，因为它也用于乘法和解引用上。</p>
<p><strong>如何阅读指针的声明</strong>：倒过来读！（能够很清楚地区分常指针还是指向常量的指针）</p>
<p>例如：const int *pci;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，pci              pci是一个变量</span><br><span class="line">2，*pci             pci是一个指针变量</span><br><span class="line">3，int *pci         pci是一个指向int的指针变量</span><br><span class="line">4，const int *pci   pci是一个指向int常量的指针变量</span><br></pre></td></tr></table></figure>



<p>在不同平台上用一致的方式显示指针的值比较困难。一种方法是把指针转换为void指针，然后用%p格式说明符来显示，如下（%p是十六进制大写形式）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Value of pi: %p\n"</span>,(<span class="keyword">void</span>*)pi);</span><br></pre></td></tr></table></figure>



<p>间接引用操作符（<em>）返回指针变量指向的值，一般称为解引指针。也可以把解引用操作符的结果用作*</em>左值**，即可以对所引用的值进行修改。</p>
<p>指向函数的指针，例如，函数没有参数也没有返回值，指针的名字为foo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*foo)();</span><br></pre></td></tr></table></figure>

<p>关于函数指针，函数指针数组之类的阅读方式或者区分方法见我的博客（<a href="https://blog.csdn.net/Alieon/article/details/114598505）" target="_blank" rel="noopener">https://blog.csdn.net/Alieon/article/details/114598505）</a></p>
<p><strong>null的概念</strong>：null很有趣，但是有时候会被误解。之所以会造成迷惑，是因为我们会遇到几种类似但是又不一样的概念，包括：</p>
<ul>
<li>null概念</li>
<li>null指针常量</li>
<li>NULL宏</li>
<li>ASCII字符NUL</li>
<li>null字符串</li>
<li>null语句</li>
</ul>
<p>在C语言中，NULL宏是强制类型转换为void指针的整数常量0，在很多库中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>

<p>而null概念是通过null指针常量来支持的一种抽象。这个常量可能是0，也可能不是0（可以是’\0’）。特别需要注意的是，不能在需要ASCII空字符（NUL）的地方用NULL，如果确实需要可以自定义为：#define NUL ‘\0’</p>
<p>由此可见，在C中，NULL可以确保是0，但是空指针不一定是0（参考：<a href="http://c.biancheng.net/view/364.html）。" target="_blank" rel="noopener">http://c.biancheng.net/view/364.html）。</a></p>
<p>还需要注意的是，这一部分与C++的区别。在C++中，NULL被定义为0，而不是<code>(void*)0</code>，同时C++使用nullptr表示空指针，可以转换成任何类型的指针或者bool类型，但是不能转换成整数。这么做的主要原因是，C++中不能将<code>void*</code>类型的指针隐式转换成其他指针类型，所以将NULL定义为<code>(void*)0</code>的话并不能起到空指针的作用。</p>
<p>参考：<a href="https://blog.csdn.net/u012707739/article/details/77915483" target="_blank" rel="noopener">https://blog.csdn.net/u012707739/article/details/77915483</a></p>
<p><font color="red">注意</font>：</p>
<ol>
<li>null指针和未初始化的指针不同。未初始化的指针可能包含任何值，而包含NULL的指针则不会引用内存中的任何地址。有趣的是，我们可以给指针赋0，但是不能赋任何别的整数值。</li>
<li>任何时候都不应该对null指针进行解引用，因为它们并不包含合法地址。执行这样的代码会导致程序终止。</li>
</ol>
<p><strong>void指针</strong></p>
<p>void指针是通用指针，用来存放任何数据类型的引用，它有两个有趣的性质：</p>
<ul>
<li>void指针具有与char指针相同的形式和内存对齐方式</li>
<li>void指针与别的指针永远不会相等，不过，两个赋值为NULL的void指针是相等的</li>
</ul>
<p>void指针只用做数据指针，而不能用做函数指针。在8.4.2节中，我们将再次研究如何用void指针来解决多态的问题。</p>
<p>sizeof操作符可以作用在void指针上，但是无法作用在void上，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);     <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">void</span>);      <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>



<p><strong>全局和静态指针</strong></p>
<p>指针被声明为全局或静态，就会在程序启动时被初始化为NULL。下面是全局和静态指针的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *globalPi;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> *staticPi;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针的长度和类型"><a href="#指针的长度和类型" class="headerlink" title="指针的长度和类型"></a>指针的长度和类型</h3><p>如果考虑应用程序的兼容性和可移植性，指针长度就是一个问题。32位系统中指针长度为4字节，而64位系统中指针的长度为8字节。</p>
<p>使用指针时经常会用到以下四种预定义类型：</p>
<ul>
<li>size_t: 用于安全地表示长度</li>
<li>ptrdiff_t: 用于处理指针算术运算</li>
<li>intptr_t和uintptr_t: 用于存储指针地址</li>
</ul>
<p>（1）<strong>理解size_t</strong></p>
<p>size_t类型表示C中任何对象所能达到的最大长度。它是无符号整数，因为负数在这里没有意义。</p>
<p>它的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。size_t用做sizeof操作符的返回值类型，同时也是很多函数的参数类型，包括malloc和strlen。</p>
<p>打印size_t类型的值时要小心，这是无符号值，不要选错了格式说明符，建议使用%zu，但有时不能用这个，也可以考虑%u或%lu。</p>
<p>（2）对指针使用sizeof操作符</p>
<p>当需要用指针长度时，一定要用sizeof操作符。</p>
<p>（3）<em>使用intptr_t和uintptr_t</em></p>
<p>intptr_t和uintptr_t类型用来存放指针地址。它们提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同，对于把指针转化为整数形式来说很有用。uintptr_t是intptr_t的无符号版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">intptr_t</span> *pi = &amp;num;</span><br></pre></td></tr></table></figure>

<p>参考博客：<a href="https://blog.csdn.net/justlinux2010/article/details/7490420" target="_blank" rel="noopener">https://blog.csdn.net/justlinux2010/article/details/7490420</a></p>
<p>可以将intptr_t理解成一种void* 类型的指针。</p>
<h3 id="指针操作符"><a href="#指针操作符" class="headerlink" title="指针操作符"></a>指针操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td></td>
<td>声明指针</td>
</tr>
<tr>
<td>*</td>
<td>解引用</td>
<td>解引指针</td>
</tr>
<tr>
<td>-&gt;</td>
<td>指向</td>
<td>访问指针引用的结构的字段</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>对指针做加法</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>对指针做减法</td>
</tr>
<tr>
<td>==    !=</td>
<td>相等、不等</td>
<td>比较两个指针</td>
</tr>
<tr>
<td>&gt;  &gt;=  &lt;  &lt;=</td>
<td>关系运算</td>
<td>比较两个指针</td>
</tr>
<tr>
<td>(数据类型)</td>
<td>转换</td>
<td>改变指针的类型</td>
</tr>
</tbody></table>
<p>（1）<strong>给指针加上/减去整数</strong></p>
<p>这种操作很普遍且有用。<strong>给指针加上一个整数实际上加的数是这个整数和指针数据类型对应字节数的乘积</strong>，减也同理。（这句话就能解决所有指针偏移的题目了，重点就是看指针是什么类型的）例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short s;</span><br><span class="line">short *ps = &amp;s;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">char</span> *pc = &amp;c;</span><br></pre></td></tr></table></figure>

<p>对ps指针加1，ps指向的地址加2；而对pc指针加1，pc指向的地址加1。</p>
<p>（2）<strong>void指针和加法</strong></p>
<p>作为扩展，大部分编译器都允许给void指针做算术运算，这里我们假设void指针的长度是4。不过，试图为void指针加1可能导致语法错误。在下面的代码中，我们声明指针并试图给它加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,pv);</span><br><span class="line">pv = pv+<span class="number">1</span>;     <span class="comment">// 语法警告</span></span><br></pre></td></tr></table></figure>

<p>警告内容：<code>warning: pointer of type &#39;void *&#39; used in arithmetic [-Wpointerarith]</code></p>
<p>这不是标准C允许的行为，所以编译器发出了警告。不过，pv包含的地址增加了4字节。（实际测试Ubuntu18.04 64bits的时候，void指针+1地址只加了1，而int类型指针+1，地址加了4）</p>
<p>（3）<strong>指针相减</strong></p>
<p>一个指针减去另一个指针会得到两个地址的差值。这个差值通常没什么用，但是可以判断数组中的元素顺序。</p>
<p>指针之间的差值是它们之间相差的“单位”数，也就是差的元素个数，而并不是地址之间差的值。结果的符号取决于操作数的顺序，可正可负。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[] = &#123;<span class="number">28</span>,<span class="number">41</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p0 = <span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in">vector</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p2-p0: %d\n"</span>,p2-p0);    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p0-p2: %d\n"</span>,p0-p2);    <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>



<h3 id="指针的常见用法"><a href="#指针的常见用法" class="headerlink" title="指针的常见用法"></a>指针的常见用法</h3><p>指针的用处很多，本节主要探<code>讨多层间接引用</code>和<code>常量指针</code>。</p>
<p>（1）多层间接引用</p>
<p>也就是指针的指针。可以为代码提供更多的灵活性，但是层数过多会让人迷惑</p>
<p>（2）常量指针</p>
<ul>
<li><p>指向常量的指针</p>
<p>将指针定义为指向常量，这意味着不能通过指针修改它所引用的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci;</span><br><span class="line"></span><br><span class="line">pci = &amp;limit;</span><br></pre></td></tr></table></figure>

<p>把pci声明为指向整数常量的指针意味着：</p>
<ul>
<li>pci可以被修改为指向不同的int或const int</li>
<li>可以解引pci以读取数据</li>
<li>不能解引pci从而修改它指向的数据</li>
</ul>
</li>
<li><p>指向非常量的常量指针</p>
<p>声明一个指向非常量的常量指针，这么做意味着指针不可变，但是它指向的数据可变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> cpi = &amp;num;</span><br></pre></td></tr></table></figure>

<p>这个声明表示：</p>
<ul>
<li><strong>cpi必须被初始化指向非常量</strong></li>
<li>cpi不可被修改</li>
<li>cpi指向的数据可以被修改</li>
</ul>
</li>
<li><p>指向常量的常量指针</p>
<p>这种指针很少使用。指针本身不能修改，它指向的数据也不能<strong>通过</strong>它来修改。</p>
<p>注意：并不代表着它指向的数据不能修改，而是不能通过它来修改，因为它也可以指向非常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> cpci = &amp;limit;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="C的动态内存管理"><a href="#C的动态内存管理" class="headerlink" title="C的动态内存管理"></a>C的动态内存管理</h2><p>指针的强大很大程度上源于它们能追踪动态分配的内存。通过指针来管理这部分内存是很多操作的基础，包括一些用来处理复杂数据结构的操作。</p>
<p>由于可以先分配内存然后释放，因而应用程序可以更灵活高效地管理内存。在C99之前数组是固定长度的，而C99引入了变长数组（柔性数组），数组长度在运行时确定，而不是编译时。</p>
<p>堆上分配的内存，使用分配和释放函数手动实现的，这个过程被称为<em>动态内存管理</em>。</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>C中动态分配内存的基本步骤有：</p>
<ol>
<li>用malloc类的函数分配内存</li>
<li>用这些内存支持应用程序</li>
<li>用free函数释放内存</li>
</ol>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*pi = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*pi:\n"</span>,*pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br></pre></td></tr></table></figure>

<p>sizeof操作符使应用程序更容易移植，还能确定在宿主系统中应该分配的正确字节数。如果写成(int*)malloc(4)，根据不同的系统，int长度可能有差别，不具备移植性。</p>
<p><font color="red">注意：每次调用malloc，程序结束时必须有对应的free函数调用，以防止内存泄漏。</font></p>
<p>一旦内存释放，就不应该访问它了，但也可能有意外发生，最好的做法是总是把被释放的指针赋值为NULL。</p>
<p>分配内存时，堆管理器维护的数据结构中会保存额外的信息。这些信息包括块大小和其他一些东西，通常放在紧挨着分配块的位置。如果应用程序的写入操作超出了这块内存，数据结构可能会被破坏，还可能造成程序奇怪的行为或者堆损坏。</p>
<p><strong>内存泄漏</strong></p>
<p>如果不再使用已分配的内存却没有将其释放就会发生泄漏，导致内存泄漏的情况可能如下：</p>
<ul>
<li>丢失内存地址</li>
<li>应该调用free函数却没有调用（有的称为隐式泄漏）</li>
</ul>
<p>内存泄漏的一个问题就是无法回收内存并重复利用，堆管理器可用的内存将变少。如果内存不断被分配并丢失，那么当需要更多内存而malloc又不能分配时程序可能会终止，用为它用光了内存。在极端情况下，操作系统可能崩溃。</p>
<p>内存泄漏的方式：</p>
<ol>
<li><p>丢失地址</p>
<p>下面代码说明了当pi被赋值为一个新地址是丢失内存地址的例子。当pi又指向第二次分配的内存时，第一次分配的内存的地址就会丢失。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*pi = <span class="number">5</span>;</span><br><span class="line">...</span><br><span class="line">pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式内存泄漏</p>
<p>如果程序应该释放内存而实际却没有释放，也会发生内存泄漏。</p>
<p>如果我们不再需要某个对象但它仍然保存在堆上，就会发生隐式内存泄漏。</p>
<p>注意：在释放用struct关键字创建的结构体时也可能发生内存泄漏。如果结构体包含指向动态分配的内存的指针，那么可能需要在释放结构体之前先释放这些指针。</p>
</li>
</ol>
<h3 id="动态内存分配函数"><a href="#动态内存分配函数" class="headerlink" title="动态内存分配函数"></a>动态内存分配函数</h3><p>有一些内存分配函数可以用来管理动态内存，虽然具体可用的函数还是取决于系统，但大部分系统的stdlib.h头文件中都有如下函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>malloc</td>
<td>从堆上分配内存</td>
</tr>
<tr>
<td>realloc</td>
<td>在之前分配的内存块的基础上，<br />将内存重新分配为更大或者更小的部分</td>
</tr>
<tr>
<td>calloc</td>
<td>从堆上分配内存，并清零</td>
</tr>
<tr>
<td>free</td>
<td>将内存块返回堆</td>
</tr>
</tbody></table>
<p>动态内存从堆上分配，但对于一连串内存分配调用，系统不保证内存的顺序和所分配内存的连续性。不过，分配的内存会根据指针的数据类型对齐。堆管理器返回的地址是最低字节的地址。</p>
<h4 id="使用malloc函数"><a href="#使用malloc函数" class="headerlink" title="使用malloc函数"></a><strong>使用malloc函数</strong></h4><p>malloc函数从堆上分配一块内存，所分配的字节数由该函数唯一的参数指定，<em>返回值为void指针</em>。如果内存不足，就会返回NULL。</p>
<p>此函数不会清空或者修改内存，所以我们认为新分配的内存包含垃圾数据。函数原型如下：</p>
<p><code>void* malloc(size_t);</code></p>
<p>需要注意的是，如果参数是负数就会引发问题，在有的系统中，参数为负会返回NULL。</p>
<p>以下是malloc函数的典型用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != pi)&#123;</span><br><span class="line">	<span class="comment">// 指针没问题</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// 无效的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc有可能返回NULL，所以在使用它返回的指针前需要先检查NULL。</p>
<p>两个问题：</p>
<p>1，要不要强制类型转换</p>
<p>C在引入void指针之前，在两种互不兼容的指针之间赋值需要对malloc使用显式转换类型以避免产生警告。但是引入void指针后，可以将void指针赋值给其他任何指针类型，所以就不再需要显式类型转换了。</p>
<p>但是有些开发者认为显式类型转换也是不错的做法，因为：</p>
<ul>
<li>这样可以说明malloc函数的用意</li>
<li>代码可以和C++（或早期的C编译器）兼容，后两者需要显式类型转换</li>
</ul>
<p>2，静态、全局指针和malloc</p>
<p>初始化静态和全局变量时不能调用函数。下面代码声明一个静态变量，并试图用malloc来初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> *pi = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>这样做会产生一个编译时错误消息，全局变量也一样。</p>
<p>对于静态变量，可以通过在后面用一个单独的语句给变量分配内存来避免这个问题。</p>
<p><font color="red">注意：在编译器看来，作为初始化操作符的 <code>=</code> 和作为赋值操作符的 <code>=</code> 不一样。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> *pi;</span><br><span class="line">	pi = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于全局变量，不能用单独的赋值语句，因为全局变量是在函数和可执行代码外部声明的。</p>
<h4 id="使用calloc函数"><a href="#使用calloc函数" class="headerlink" title="使用calloc函数"></a>使用calloc函数</h4><p>calloc函数会在分配的同时清空内存（将内容置为二进制0）。该函数原型如下：</p>
<p><code>void* calloc(size_t numElements, size_t elementSize);</code></p>
<p>calloc函数会根据<code>numElements</code>和<code>elementSize</code>两个参数的乘积来分配内存，并返回一个指向内存的第一个字节的指针。如果不能分配内存，则会返回NULL。</p>
<p>如果<code>numElements</code>或者<code>elementSize</code>为0，那么calloc可能返回空指针。若calloc无法分配内存就会返回空指针，而且全局变量<code>errno</code>会设置成<code>ENOMEM</code>（内存不足），这是POSIX错误码，有的系统上可能没有。</p>
<blockquote>
<p>错误码可以参考：<a href="https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html" target="_blank" rel="noopener">https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html</a></p>
</blockquote>
<p>下例为pi分配了20字节，并全部都为0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//不用calloc的话，用malloc和memset也可以得到一样的结果</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="built_in">malloc</span>(<span class="number">5</span>* <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(pi, <span class="number">0</span>, <span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>如果内存需要清零可以使用calloc，不过执行calloc可能比执行malloc慢。</p>
<h4 id="使用realloc函数"><a href="#使用realloc函数" class="headerlink" title="使用realloc函数"></a>使用realloc函数</h4><p>我们可能需要时不时地增加或减少为指针分配的内存，如果需要一个变长数组这种做法尤其有用。而<code>realloc</code>函数会重新分配内存，下面是它的原型：</p>
<p><code>void* realloc(void* ptr, size_t size);</code></p>
<p><code>realloc</code>函数返回指向内存块的指针。接受两个参数，第一个是指向内存块的指针，第二个请求的大小。</p>
<p>重新分配的块大小与第一个参数引用的块大小不同，或大或小。如果重新分配的空间更小，则多余的内存会还给堆，但是内容并不会被清空；如果第二个参数为<code>0</code>，而指针非空，那么就会释放内存。如果无法分配空间，那么原来的内存块就保持不变，但是返回的是空指针，而且<code>errno</code>会设置为<code>ENOMEM</code>。</p>
<p>该函数的行为可以概括为：</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>空</td>
<td>/</td>
<td>同malloc</td>
</tr>
<tr>
<td>非空</td>
<td>0</td>
<td>原内存块被释放</td>
</tr>
<tr>
<td>非空</td>
<td>比原内存小</td>
<td>利用当前块分配更小的块</td>
</tr>
<tr>
<td>非空</td>
<td>比原内存大</td>
<td>要么在当前位置要么在其他位置分配更大的块</td>
</tr>
</tbody></table>
<h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><p>C99引入了变长数组（VLA），允许函数内部声明和创建其长度由变量决定的数组。在下例中，我们分配了一个在函数内使用的char数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="built_in">size</span>];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着内存分配在运行时完成，且将内存作为栈帧的一部分来分配。另外，如果数组用到<code>sizeof</code>操作符，也是在运行时而不是编译时执行。</p>
<p>VLA的长度不能改变，一经分配其长度就固定了。如果需要一个长度能够实际变化的数组，那么需要使用类似<code>realloc</code>的函数。</p>
<h3 id="用free函数释放内存"><a href="#用free函数释放内存" class="headerlink" title="用free函数释放内存"></a>用free函数释放内存</h3><p>动态内存的释放通常用<code>free</code>函数来实现，它的原型是：</p>
<p><code>void free(void *ptr);</code></p>
<p>指针参数<code>ptr</code>应该指向由<code>malloc</code>类函数分配的内存地址，这块内存会被返还给<strong>堆</strong>。下面是一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br></pre></td></tr></table></figure>

<p>如果传递给<code>free</code>函数的参数是空指针，通常它什么都不做。<font color="red">如果传入的指针所指向的内存并不是由<code>malloc</code>类的函数分配，那么该函数的行为将是未定义的</font>。在下面的例子中，分配给<code>pi</code>的是<code>num</code>的地址，不过这<strong>不是一个合法的堆地址</strong>，而是栈地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> *pi = &amp;num;</span><br><span class="line">    <span class="built_in">free</span>(pi);     <span class="comment">// 未定义行为！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="将已释放的指针赋值为NULL"><a href="#将已释放的指针赋值为NULL" class="headerlink" title="将已释放的指针赋值为NULL"></a>将已释放的指针赋值为NULL</h4><p>已释放的指针仍然可能造成问题。如果我们试图解引一个已释放的指针，其行为将是未定义的。所以有些程序员会显式地给指针赋值NULL来表示该指针无效，后续再使用这种指针将会造成运行时异常。</p>
<h4 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h4><p><code>重复释放</code>是指两次释放同一块内存。下面是一个简单的例子（也是经常可能会犯的错误）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> *p2 = p1;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>

<p>调用第二个<code>free</code>函数会导致运行时异常。 </p>
<p>堆管理器很难判断一个块是否已经被释放，因此它们不会试图去检测是否两次释放了同一块内存。有人建议free函数应该在返回时应该将NULL或者其他某个特殊值赋给自身的参数。<strong>但是指针是传值的</strong>，因此free函数无法显式地给它赋值NULL。</p>
<p>关于指针是传值的，如果不理解可以去做做牛客的这道题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">( <span class="keyword">double</span> *pl,<span class="keyword">double</span> *p2,<span class="keyword">double</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s ＝ ( <span class="keyword">double</span>*) <span class="built_in">calloc</span> ( <span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    *s ＝ *pl + *(p2+<span class="number">1</span>);</span><br><span class="line">｝</span><br><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> a [<span class="number">2</span>] ＝ ｛<span class="number">1.1</span>,<span class="number">2.2</span>｝,b [<span class="number">2</span>] ＝ ｛<span class="number">10.0</span>,<span class="number">20.0</span>｝, *s ＝ a;</span><br><span class="line">    fun (a,b,s);</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%5.2f\n"</span>,* s) ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>程序的输出是？(答案选D)</p>
<blockquote>
<p>A, 21.10          B, 11.10          C, 12.10          D, 1.10</p>
</blockquote>
<p>形参指针s创建实参s的副本，具有相同的地址值（图就懒得画了，可以理解为形参_s，实参s都指向a数组起始位置），但是对形参<code>calloc</code>将分配一段堆内存并将起始地址返回形参s，此时相当于形参已经丢失实参的地址了，所以后续对形参s解引修改都不对实参造成任何改变。</p>
<h3 id="迷途指针"><a href="#迷途指针" class="headerlink" title="迷途指针"></a>迷途指针</h3><p>如果<strong>内存已经释放，而指针还在引用原始内存</strong>，这样的指针就称为<code>迷途指针</code>。迷途指针没有指向有效的对象。</p>
<p>使用迷途指针会造成一系列问题，包括：</p>
<p>（1）如果访问内存，则行为不可预期</p>
<p>（2）如果内存不可访问，则是<code>段错误</code></p>
<p>（3）潜在的安全隐患</p>
<p>导致这几类问题的情况可能如下：</p>
<p>（1）访问已释放的内存</p>
<p>（2）返回的指针指向的是上次函数调用中的自动变量（在3.2.5节中会讨论）</p>
<h4 id="迷途指针示例"><a href="#迷途指针示例" class="headerlink" title="迷途指针示例"></a>迷途指针示例</h4><ul>
<li><p>访问已释放的内存</p>
<p>我们用<code>malloc</code>函数为一个整数分配内存，然后用<code>free</code>函数释放内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*pi = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*pi: %d\n"</span>, *pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br></pre></td></tr></table></figure>

<p>此时<code>pi</code>仍然持有整数的地址，但是这块内存已经被释放了，堆管理器可以重复使用这块内存，且后续存放的可能是非整数数据，这都是不可预期的。</p>
<p>还有一种迷途指针的情况更难察觉：一个以上的指针引用同一块内存区域而其中一个指针被释放。</p>
</li>
<li><p>指向栈中的内存，但是数据离开作用域，出栈之后地址无效</p>
<p>块语句，函数返回局部变量的地址，这些情况也会造成迷途指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">5</span>;</span><br><span class="line">	pi = &amp;tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里pi就变成了迷途指针</span></span><br></pre></td></tr></table></figure>

<p>在这个块语句之后，<code>pi</code>就成了迷途指针。因为大部分编译器都<strong>把块语句当作一个栈帧</strong>。<code>tmp</code>变量分配在栈帧上，之后在块语句退出时会出栈。</p>
</li>
</ul>
<h4 id="处理迷途指针"><a href="#处理迷途指针" class="headerlink" title="处理迷途指针"></a>处理迷途指针</h4><p>有时候调试指针诱发的问题会很难解决，以下方法可以用来对付迷途指针：</p>
<ul>
<li>释放指针后置为<code>NULL</code>，后续使用这个指针会终止应用。</li>
<li>写一个特殊的函数代替<code>free</code>函数。</li>
<li>有些系统会在释放后覆写数据（比如 0xDEADBEEF）。在不抛出异常的情况下，如果程序员在预期之外的地方看到这些值，可以认为程序可能在访问已释放的内存。</li>
<li>使用第三方工具检测迷途指针和其他问题。</li>
</ul>
<h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h2><p>指针对函数功能的贡献极大。它们能够将数据传递给函数，并允许函数对数据进行修改。可以将复杂数据用结构体指针的形式传递给函数和从函数返回。如果指针持有函数的地址，那么就能动态控制程序的执行流。</p>
<p>要理解函数及其和指针的结合使用，需要理解程序栈。大部分现代的块结构语言，都用到了程序栈来支持函数执行。调用函数时，会创建函数的栈帧并将其推到程序栈上。函数返回时，其栈帧从程序栈上弹出。</p>
<p>使用函数时，有两种情况指针很有用：</p>
<ol>
<li>将指针传递给函数：函数可以修改指针所引用的数据，并且可以更高效地传递大块信息</li>
<li>声明函数指针：可以控制程序的执行流</li>
</ol>
<h3 id="程序的栈"><a href="#程序的栈" class="headerlink" title="程序的栈"></a>程序的栈</h3><h4 id="程序栈"><a href="#程序栈" class="headerlink" title="程序栈"></a>程序栈</h4><p>程序栈是支持函数执行的内存区域，通常和堆共享。也就是说，它们共享同一块内存区域，程序栈通常占据这块区域的下部，而堆用的则是上部。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/04/12/YSdXkyf1tVbwnsT.png" alt="stack.png"></p>
<p>程序栈存放栈帧，栈帧有时候也成为<code>活跃记录</code>。栈帧存放函数参数和局部变量；堆管理动态内存。</p>
<p>调用函数时，函数的堆栈被推到栈上，栈向上“长出”一个栈帧。当函数终止时，其栈帧从程序栈上弹出。栈帧所使用的内存不会被清理，但最终可能会被推到程序栈上的另一个栈帧覆盖。</p>
<p>动态分配的内存来自堆，堆向下“生长”。随着内存的分配和释放，堆中会布满碎片。尽管堆是向下生长的，但这只是个大体方向，实际上内存可能在堆上任意位置分配。</p>
<h4 id="栈帧的组织"><a href="#栈帧的组织" class="headerlink" title="栈帧的组织"></a>栈帧的组织</h4><p>（2021.4.12 未完待续…）</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://aliez22.github.io/posts/C_Pointer/">https://aliez22.github.io/posts/C_Pointer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://aliez22.github.io" target="_blank">zzm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E6%8C%87%E9%92%88/">C指针</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/040.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/63938/"><img class="prev-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/009.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">柔性数组</div></div></a></div><div class="next-post pull-right"><a href="/posts/55373/"><img class="next-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/019.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dd command</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> zzm</div><div class="framework-info"><span> &gt;明确目标 不留余力&lt; </span></div></div><head><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script></body></html>