<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Effective C++ (第三版) | zzm</title><meta name="description" content="研二上这学期真是从头忙到尾呀，后悔自己暑假没有平衡好生活和学习。最近终于搞完了科研任务和一些其他杂事，有时间来沉淀一下自己了。准备把C++路线整个走一遍，以备战明年的实习和校招，加油吧，少年！ 之前粗略地记录了C++ primer第五版，就不重复花费时间了。虽然之前也看过effective c++，但当时理解还不够，这次准备重点理解好《effective c++》和《effective stl》这"><meta name="keywords" content="C++"><meta name="author" content="zzm"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://aliez22.github.io/posts/41157/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//fastly.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Effective C++ (第三版)"><meta property="og:url" content="https://aliez22.github.io/posts/41157/"><meta property="og:site_name" content="zzm"><meta property="og:description" content="研二上这学期真是从头忙到尾呀，后悔自己暑假没有平衡好生活和学习。最近终于搞完了科研任务和一些其他杂事，有时间来沉淀一下自己了。准备把C++路线整个走一遍，以备战明年的实习和校招，加油吧，少年！ 之前粗略地记录了C++ primer第五版，就不重复花费时间了。虽然之前也看过effective c++，但当时理解还不够，这次准备重点理解好《effective c++》和《effective stl》这"><meta property="og:image" content="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/038.webp"><meta property="article:published_time" content="2022-10-12T12:46:41.000Z"><meta property="article:modified_time" content="2023-02-12T03:45:55.037Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="【bug】局部数组变量过大导致栈溢出" href="https://aliez22.github.io/posts/31760/"><link rel="next" title="【开源项目】为openEuler5.10内核增添页表检查功能" href="https://aliez22.github.io/posts/23548/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-02-12 11:45:55'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars.githubusercontent.com/u/34917442" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#导读"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#让自己习惯C"><span class="toc-text">让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款01：视C-为一个语言联邦"><span class="toc-text">条款01：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款02：尽量以const-enum-inline-替代-define"><span class="toc-text">条款02：尽量以const, enum, inline 替代 #define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款03：尽可能使用const"><span class="toc-text">条款03：尽可能使用const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款04：确定对象被使用前已先被初始化"><span class="toc-text">条款04：确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造、析构、赋值运算"><span class="toc-text">构造、析构、赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款05：了解C-默默编写并调用了哪些函数"><span class="toc-text">条款05：了解C++默默编写并调用了哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><span class="toc-text">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款07：为多态基类声明virtual析构函数"><span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款08：别让异常逃离析构函数"><span class="toc-text">条款08：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款09：绝不在构造和析构过程中调用virtual函数"><span class="toc-text">条款09：绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款10：令operator-返回一个reference-to-this"><span class="toc-text">条款10：令operator&#x3D;返回一个reference to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款11：在operator-中处理“自我赋值”"><span class="toc-text">条款11：在operator&#x3D;中处理“自我赋值”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款12：复制对象时勿忘其每个成分"><span class="toc-text">条款12：复制对象时勿忘其每个成分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源管理"><span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款13：以对象管理资源"><span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款14：在资源管理类中小心copying行为"><span class="toc-text">条款14：在资源管理类中小心copying行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款15：在资源管理类中提供对原始资源的访问"><span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款16：成对使用new和delete时要采取相同形式"><span class="toc-text">条款16：成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款17：以独立语句将newed对象放入智能指针"><span class="toc-text">条款17：以独立语句将newed对象放入智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计与声明"><span class="toc-text">设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款18：让接口容易被正确使用，不易被误用"><span class="toc-text">条款18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款19：设计class犹如设计type"><span class="toc-text">条款19：设计class犹如设计type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款20：宁以-pass-by-reference-to-const-替换-pass-by-value"><span class="toc-text">条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款21：必须返回对象时，别妄想返回其reference"><span class="toc-text">条款21：必须返回对象时，别妄想返回其reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款22：将成员变量声明为private"><span class="toc-text">条款22：将成员变量声明为private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款23：宁以-non-member、non-friend-替换-member-函数"><span class="toc-text">条款23：宁以 non-member、non-friend 替换 member 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款24：若所有参数都需类型转换，请为此采用-non-member-函数"><span class="toc-text">条款24：若所有参数都需类型转换，请为此采用 non-member 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款25：考虑写出一个不抛异常的swap函数"><span class="toc-text">条款25：考虑写出一个不抛异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款26：尽可能延后变量定义式的出现时间"><span class="toc-text">条款26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款27：尽量少做转型动作"><span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款28：避免返回handles指向对象内部成分"><span class="toc-text">条款28：避免返回handles指向对象内部成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款29：为“”异常安全“而努力是值得的"><span class="toc-text">条款29：为“”异常安全“而努力是值得的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款30：透彻了解inlining的里里外外"><span class="toc-text">条款30：透彻了解inlining的里里外外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款31：将文件间的编译依存关系降至最低"><span class="toc-text">条款31：将文件间的编译依存关系降至最低</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承与面向对象设计"><span class="toc-text">继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款32：确定你的public继承塑模出-is-a-关系"><span class="toc-text">条款32：确定你的public继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款33：避免遮掩继承而来的名称"><span class="toc-text">条款33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款34：区分接口继承和实现继承"><span class="toc-text">条款34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款35：考虑virtual函数以外的其他选择"><span class="toc-text">条款35：考虑virtual函数以外的其他选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款36：绝不重新定义继承而来的-non-virtual-函数"><span class="toc-text">条款36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款37：绝不重新定义继承而来的缺省参数值"><span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款38：通过复合塑模出has-a或“根据某物实现出”"><span class="toc-text">条款38：通过复合塑模出has-a或“根据某物实现出”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款39：明智而审慎地使用private继承"><span class="toc-text">条款39：明智而审慎地使用private继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条款40：明智而审慎地使用多重继承"><span class="toc-text">条款40：明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板与泛型编程"><span class="toc-text">模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条款41：了解隐式接口和编译期多态"><span class="toc-text">条款41：了解隐式接口和编译期多态</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/038.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">zzm</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Effective C++ (第三版)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-10-12 20:46:41"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-10-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-02-12 11:45:55"><i class="fas fa-history fa-fw"></i> 更新于 2023-02-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>研二上这学期真是从头忙到尾呀，后悔自己暑假没有平衡好生活和学习。最近终于搞完了科研任务和一些其他杂事，有时间来沉淀一下自己了。准备把C++路线整个走一遍，以备战明年的实习和校招，加油吧，少年！</p>
<p>之前粗略地记录了C++ primer第五版，就不重复花费时间了。虽然之前也看过effective c++，但当时理解还不够，这次准备重点理解好《effective c++》和《effective stl》这两本书。</p>
<p>🆗，那就一起来揭开，the 55 specific ways to improve your programs and designs.     —— Scott Meyers</p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>声明（declaration）告诉编译器某个东西的名称和类型。</p>
<p>定义（definition）提供编译器一些声明所遗漏的细节。于对象而言，定义是编译器为此对象拨发内存的地点；于函数而言，定义提供了代码本体。对类class而言，定义列出它们的成员。</p>
<p>初始化（initialization）是“给予对象初值”的过程。对用户自定义类型的对象来说，初始化由构造函数执行。</p>
<blockquote>
<p>区别“copy构造”和“copy赋值”</p>
<p>“=” 既可以表示赋值，也可以表示拷贝构造。而区分也是很简单的，如果有新对象被定义，那么一定会有构造函数调用，就一定是copy构造。</p>
</blockquote>
<p>copy构造函数是一个尤其重要的函数，它定义一个对象如何 <strong><em>passed by value</em></strong>（以值传递），例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasAcceptableQuality</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">...</span><br><span class="line">Widget aWidget;</span><br><span class="line"><span class="keyword">if</span>(hasAcceptableQuality(aWidget)) ...</span><br></pre></td></tr></table></figure>

<p>这里参数w以 <strong><em>by value</em></strong> 的方式传递，借用的就是<em>Widget</em>的拷贝构造函数。</p>
<p><code>建议就是：以by value传递用户自定义类型通常是个坏主意，pass-by-reference-to-const往往是较好的选择。</code></p>
<p>指针和引用类型的命名规范：指针（pt，pointer to T），引用（rt，reference to T）。</p>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>C++现在已是一个多重泛型编程语言，支持：过程形式、面向对象形式、函数形式、泛型形式以及元编程形式等。</p>
<p>C语言的局限：没有模板、没有异常、没有重载。。。</p>
<p>C++面向对象方面：类（构造函数和析构函数）、封装、继承、多态、virtual函数（动态绑定）等。</p>
<p>STL，是一个模板程序库，对容器、迭代器、算法以及函数对象的规约有极佳的密切配合。</p>
<h3 id="条款02：尽量以const-enum-inline-替代-define"><a href="#条款02：尽量以const-enum-inline-替代-define" class="headerlink" title="条款02：尽量以const, enum, inline 替代 #define"></a>条款02：尽量以const, enum, inline 替代 #define</h3><p>#define定义的记号名称会被<strong>预处理器</strong>处理，却不会被<strong>编译器</strong>看到，这样调试时会无法追踪到这个记号，而导致浪费时间。</p>
<p>使用<strong>const</strong>的注意事项：</p>
<ol>
<li>确定指针是否有必要定义为<code>const</code></li>
<li>const变量作为类成员(作用域在类内)，若只需要保留一份，则加<code>static</code></li>
</ol>
<p>使用<strong>enum hack</strong>补偿做法: enum的行为更像#define。取const地址是合法的，而取#define和enum的地址是不合法的。如果不想让别人获得一个pointer或者reference指向整数常量，enum就可以实现这个约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; numTurn = <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>对于常量，最好以const对象或者enums，替换#define。</p>
<p>对于形似函数的宏，最好改用inline函数，替换#define。</p>
<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>const允许定义一个语义约束，即指定一个“不该被改动”的对象。</p>
<p>修饰指针及内容时，原则是“左物右指”，即星号左边的const表示所指物是常量，而星号右边的const表示指针本身是常量。</p>
<p>STL的迭代器以指针为根据塑造，类似于一个 <code>T* 指针</code>。注意的是，声明迭代器为const相当于声明指针为const（即，T* const），表示迭代器不可更换指向，但所指物的指是可以改变的。如果希望迭代器所指的东西不可被改动（即，希望const T*），那么应该使用 <code>const_iterator</code>. 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();        <span class="comment">// int * const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                                 <span class="comment">// 可以，改变所指物的值</span></span><br><span class="line">++iter;                                                     <span class="comment">// 错误，const指针不可改变指向</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();       <span class="comment">// const int *</span></span><br><span class="line">*cIter = <span class="number">10</span>;                                                <span class="comment">// 错误，所指物的值不可改变</span></span><br><span class="line">++cIter;                                                    <span class="comment">// 可以，改变指针指向</span></span><br></pre></td></tr></table></figure>

<p><strong>const成员函数</strong> 是很重要的一类成员函数，因为：</p>
<ul>
<li>使class接口容易被理解，哪些函数可以改动对象内容，而哪些不能。</li>
<li>使“操作const对象”成为可能。</li>
</ul>
<p>例如，用const重载operator []来对不同版本的对象返回不同的返回类型。试想，如果const对象调用operator [] 没有得到const相应类型，那么就可以被修改了，这样是不对的。而重载两种 operator [] 又要<em>避免代码冗余</em>，就可以使用转型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ...   <span class="comment">// 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&gt;(*<span class="keyword">this</span>)[<span class="built_in">position</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让non-const 调用 const成员函数，non-const版本中有两个转型，第一个<code>static_cast&lt;const TextBlock&gt;</code>则是为了调用const版本的成员函数，防止non-const版本循环调用。第二个<code>const_cast&lt;char&amp;&gt;</code>用于消除const成员函数返回值类型的const部分。</p>
<p>小结，当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本能够避免代码重复。</p>
<h3 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h3><p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。这意味着，构造函数内的操作其实是赋值，而非初始化。初始化发生的时机更早，发生于成员的<strong>default</strong>构造函数被自动调用的时候。而在对象构造时初始化的一个较佳写法是，使用<strong>成员初值列表</strong>（member initialization list）替换赋值动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address, </span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    :theName(name),</span><br><span class="line">     theAddress(address),</span><br><span class="line">     thePhones(phones),</span><br><span class="line">     numTimesConsulted(<span class="number">0</span>)</span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式通常更高效，省去了赋值的过程，成员的初值由它们的default构造函数初始化。</p>
<p>规定一下，在<em>成员初值列表</em>中总是按声明的顺序列出所有成员变量，以免还得记住哪些成员变量可以无需初值。</p>
<blockquote>
<p>C++有十分<strong>固定的“成员初始化次序”</strong>，即（1）基类总是早于派生类被初始化；（2）类的成员变量总是以声明的次序被初始化。</p>
</blockquote>
<p>一个问题是，不同编译单元内的non-local static对象的初始化相对次序是不明确的，不过可以使用<em>单例模式</em>解决，即不直接调用non-local static对象，而是调用其专属函数（首次调用时初始化，否则返回引用）。这种方式也是将 non-local static 对象转化成了 local static 对象。</p>
<h2 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h2><h3 id="条款05：了解C-默默编写并调用了哪些函数"><a href="#条款05：了解C-默默编写并调用了哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用了哪些函数"></a>条款05：了解C++默默编写并调用了哪些函数</h3><p>如果写了一个空类，那么编译器会自动为其编写构造、析构、copy构造和copy赋值函数（都是public且inline的），当这些函数被需要时，它们就会被编译器创建。类似于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty()&#123;...&#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">    ~Empty()&#123;...&#125;</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，编译器产生的析构函数是 non-virtual ，除非这个类的基类自身声明有virtual析构函数（这种情况下该函数的虚属性来自于基类）。关于虚析构函数的讨论见：<a href="https://baike.baidu.com/item/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/240645?fr=aladdin" target="_blank" rel="noopener">虚析构函数 | 百度百科</a></p>
<p>至于 copy构造 和 copy赋值 操作符，编译器创建的版本仅是单纯地“<u>将来源对象的每一个 non-static 成员变量拷贝到目标对象</u>”。</p>
<p>如果用户自己声明了构造函数，那么编译器将不再为类创建default构造函数。</p>
<p>如果用户定义的类中包含“reference成员”或者“const成员”，或者其基类的copy赋值操作符为private，那么编译器将拒绝自动创建copy赋值函数。reference和const成员是不可改变的，编译器不会自动生成copy赋值函数而导致这样错误的行为。此时就必须由用户自己定义copy赋值函数。</p>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>假如有一个类是唯一的，那么就不允许任何对该对象的拷贝和赋值。通常如果不希望class支持某一特定机制，只要不声明对应函数就行了，但这个策略却对 <code>copy构造</code> 和 <code>copy赋值</code> 行不通。</p>
<p>为驳回编译器自动提供的机能，通常有两种方式：</p>
<ol>
<li><p>将相应的成员函数声明为 private 并且不予实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale&amp;);         <span class="comment">// 仅声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样编译器可以防止客户拷贝HomeForSale对象，而且若其成员函数或者friend函数调用该对象的拷贝，连接器也会由于缺少定义而拒绝这一行为。</p>
</li>
<li><p>使用像 Uncopyable 这样的 base class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable()&#123;&#125;</span><br><span class="line">    ~Uncopyable()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:        <span class="comment">// 阻止copying行为</span></span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要组织HomeForSale对象被拷贝，唯一需要的就是继承Uncopyable.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>当使用工厂（factory）函数，返回基类指针时，其指向的对象必须位于heap中。因此，为避免内存和其他资源被泄露，每一个对象都应该被适当地delete掉。</p>
<blockquote>
<p>C++指出，当派生类对象经由一个基类指针被删除，而该基类带着一个 non-virtual 析构函数时，其结果未定义——实际执行时通常发生的是对象的derived部分没有被销毁。造成一个诡异的“局部销毁”对象。</p>
</blockquote>
<p>解决这个问题也很简单：给base class一个<em>virtual析构函数</em>。这样删除派生类对象就会完整地销毁整个对象，包括所有派生的部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    <span class="keyword">virtual</span> ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;             <span class="comment">// 行为正确</span></span><br></pre></td></tr></table></figure>

<p>像TimeKeeper这样的基类除了析构函数之外通常还有其他virtual函数，使得派生类得到客制化。同样地，任何class只要带有virtual函数都几乎确定应该有一个virtual析构函数。</p>
<p>当某个基类具备虚析构函数时，它的大小就有了变化。为了体现出虚函数，对象必须携带某些信息，用来在运行期间决定哪一个virtual函数该被调用。这份信息通常由一个所谓vptr（virtual table pointer）指针指出。vptr指向一个由函数指针构成的数组，成为vtbl（virtual table）；每一个带有virtual函数的类都有一个相应的vtbl，当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指向的那个函数指针。</p>
<p>继承一个带有 non-virtual 析构函数的基类，是很容易出现的一种错误行为。例如，某个具体的字符串类直接继承了STL中的string类，注意string类的析构函数是 non-virtual 的。所以，当继承一个基类时，需要注意其析构函数是否为 virtual.</p>
<p>总结一下，如果要作为基类使用且具备多态性质，那么就应该拥有一个 virtual 析构函数。</p>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p>C++不禁止析构函数吐出异常，但它不鼓励这么做。</p>
<p>Tips：为保证用户对资源类对象不忘记调用close方法（例如数据库连接），可以创建一个管理资源的类，并在其析构函数中调用close. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn()&#123;  <span class="built_in">close</span>();  &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即，不让用户使用new，delete来调用堆中的资源。这样，用户就能写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当DBConn离开作用域之后，就会析构，进而自动调用DBConnection的close()方法了。</p>
<p>然而，如果close调用导致异常，那么DBConn析构函数会传播异常。这样通常可以abort终止该异常，或者吞下异常。但是这样导致用户无法对该异常做出反应。更好的做法是提供一个普通函数，让用户有机会对可能出现的问题做出反应。这里在DBConn中设计一个close函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">                ...     <span class="comment">// 制作转运记录，记下对close的调用失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样将调用close的责任从DBConn析构函数手上转移到DBConn客户手上，但是DBConn析构函数中仍含有一个“双保险”的调用，以防粗心的客户忘记使用close方法。</p>
<h3 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h3><p>不应该在构造和析构函数期间调用virtual函数，这类调用从不下降至派生类。例如，基类的构造和析构中使用了virtual函数，那么派生类对象的基类构造期间，其对象类型是基类而不是派生类，虚函数只会被编译器解析至基类。</p>
<p>如果基类构造和析构中的虚函数是pure虚函数还好，大多数系统会中止程序；而如果是正常的虚函数，那么在构造和析构时总是会调用基类版本的虚函数，这会让你百思不得其解。</p>
<p>解决方法是将虚函数作为正常的函数，然后“令派生类将必要的信息向上传递至基类的构造函数”。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;     <span class="comment">// 作为non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)&#123;</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction(parameters): Transaction(createLogString(parameters))&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令operator=返回一个reference to *this</h3><p>赋值运算是右结合的，并且能够连锁运算。为了实现“连锁运算”，赋值操作符就必须返回一个reference指向操作符的左侧实参。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;            <span class="comment">// 返回左侧对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个协议不仅适用于标准赋值形式，也适用于所有赋值相关运算（+=, -=, *= 等等）。</p>
<h3 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在operator=中处理“自我赋值”</h3><p>“自我赋值”发生在对象赋值给自己时。这有点愚蠢，但是合法。例如a[i] = a[j]，当i==j时，其实就是自我赋值。</p>
<p>自我赋值并不一定是安全的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// 接下文，证同测试的语句</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;         <span class="comment">// pb是Widge对象的私有成员，是一个bitmap的指针</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样如果rhs本身就是this指向的对象，那么rhs.pb首先将被删除，然后new Bitmap将用一个“已删除的”对象拷贝构造，这是不应该发生的。</p>
<p>如果想要阻止这种“自我赋值的不安全性”，那么可以在函数最前面加一个“证同测试（identity test）”来检验是否遇上相同对象。或者用一个临时对象先保存要删除pb，然后在函数结束前删除。但其实这两个方式都会降低效率。</p>
<p>还有一个替换方案就是 “copy and swap”，这是一个常见而够好的<code>operator=</code>撰写方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);        <span class="comment">// 详见条款29</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，由此引出的是，任何函数如果操作一个以上的对象，都要考虑“自我赋值的安全”，即其中多个对象是同一个时，其行为是否仍热正确。</p>
<h3 id="条款12：复制对象时勿忘其每个成分"><a href="#条款12：复制对象时勿忘其每个成分" class="headerlink" title="条款12：复制对象时勿忘其每个成分"></a>条款12：复制对象时勿忘其每个成分</h3><p>当编写了一个copying函数，就应该确保：</p>
<ol>
<li>复制所有local成员变量</li>
<li>调用所有base class内<em>适当的</em>copying函数（考虑清楚是默认构造基类 or 自定义构造基类）</li>
</ol>
<p>如果<code>copy构造</code>和<code>copy赋值</code>中有相近的代码，消除重复是一个很好的想法，但是其实两者谁调用谁都说不通，所以消除copy构造和赋值代码重复的一个方法是，建立一个新的成员函数给两者调用。这样的函数往往是private而且常常命名为<code>init</code>。类似于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget()&#123;&#125;</span><br><span class="line">    init(<span class="keyword">int</span> a)&#123; <span class="keyword">this</span>-&gt;ia = a; &#125;</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs)&#123; init(rhs.ia); ...&#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123; init(rhs.ia); ...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ia;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>在获取了资源后，就有责任在不需要的时候释放掉，考虑一个标准的函数f：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Investment* pInv = createInvestment();          <span class="comment">// 调用factory函数，返回基类指针</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f函数正常获取了动态分配内存资源，并且在函数最后释放掉了。不过这个过程中还是存在着许多“隐患”，比如“…”过程中提前return了，或者循环中的goto或者continue语句导致跳过了资源释放的环节，那么就很可能导致内存泄漏的问题。</p>
<p>一个确保获取的资源总是能够被释放的方法是：<strong>将资源放到对象内</strong>。这样当控制流离开f函数后，对象的析构函数会自动释放那些资源。</p>
<p>许多资源被动态分配在heap内，然后被用在单一区块或者函数中。其实这些资源应该在离开作用域之后被释放。</p>
<p>标准程序库提供了 <code>auto_ptr</code> 就是针对以上情况而特制的解决方案。<code>auto_ptr</code> 是一个“类指针对象”，也就是所谓的<code>智能指针</code>。它的析构函数将自动对其所指对象调用<code>delete</code>。能够避免f函数潜在的资源泄露（使用auto_ptr需要包含头文件memory）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;     <span class="comment">// 手动资源管理</span></span><br><span class="line">    Widget *pw = <span class="keyword">new</span> Widget(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pw.x = "</span> &lt;&lt; pw-&gt;getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;    <span class="comment">// auto_ptr自动资源管理</span></span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">auto_pw</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">77</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pw.x = "</span> &lt;&lt; auto_pw.<span class="built_in">get</span>()-&gt;getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“以对象管理资源”有两个关键想法：</p>
<ul>
<li>获得资源后立即放进管理对象。对于资源管理对象来说，“资源获取的时机就是初始化时机”（<u>R</u>esource <u>A</u>cquisition <u>I</u>s <u>I</u>nitialization; RAII），有时候获取的资源被拿来初始化或者赋值，不管那种做法，都应该在获得资源后立马放到管理对象中。</li>
<li>管理对象运用析构函数确保资源被释放。对象离开作用域将被销毁，其析构函数会自动调用。</li>
</ul>
<p>需要注意的是，<code>auto_ptr</code> 虽然好用，但是不应该让多个 auto_ptr 同时指向同一对象。否则该对象被多次销毁，会发生未定义行为。为此，它有一个不寻常的特性：<em>通过copy构造或者copy赋值来赋值它们时，它们会变成null，而复制得到的指针将取得资源的唯一拥有权。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv1</span><span class="params">(createInvestment())</span></span>;    <span class="comment">// 创建pInv1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv2</span><span class="params">(pInv1)</span></span>;                 <span class="comment">// 利用pInv1创建pInv2, pInv1将被置为null</span></span><br><span class="line">pInv1 = pInv2;                                          <span class="comment">// pInv2赋值给pInv1, pInv2之后为null</span></span><br></pre></td></tr></table></figure>

<p>auto_ptr这种行为限制了 受其管理的资源必须绝没有一个以上auto_ptr同时指向它。</p>
<p>不过这种方式的限制并不能使问题得到解决，<strong>如果客户并没有在资源获得时就放入管理对象，那么就无法限制对象的唯一权，还是会发生内存泄露</strong>，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试auto_ptr同时指向一个对象</span></span><br><span class="line">Widget *pw = <span class="keyword">new</span> Widget(<span class="number">7</span>);</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">auto_pw1</span><span class="params">(pw)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">auto_pw2</span><span class="params">(pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>另外，在C++17中，auto_ptr已经被删除了。其代替方案是“引用型智慧指针”（<u>R</u>eference-<u>C</u>ounting <u>S</u>mart <u>P</u>ointer；RCSP）。这也是个智能指针，<em>会持续追踪共有多少对象指向某个资源，并在无人指向它时自动删除该资源</em>。TR1中的<code>tr1::shared_ptr</code>就是个RCSP，于是可以这么写f函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pIvn2</span><span class="params">(pInv1)</span></span>;           <span class="comment">// pInv1 和 pInv2指向同一个对象</span></span><br><span class="line">    pInv1 = pInv2;                                           <span class="comment">// 同上，无改变</span></span><br><span class="line">&#125;                                                            <span class="comment">// pInv1,2销毁，它们所指对象也销毁</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr 和 auto_ptr仅仅是个例子。本条款最重要的就是使用RAII对象来防止资源泄露，它们在构造函数中获得资源，并在析构函数中释放资源。</p>
<h3 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h3><p>对于非heap-based资源，智能指针往往不适合作为资源管理者。那么有时，就需要建立自己的资源管理类。例如，为确保不会忘记将一个锁住的Mutex解锁，我们希望建立一个class来管理锁的机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm)</span></span>&#123;</span><br><span class="line">        lock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Lock()&#123; unlock(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，这里存在一个一般性的问题是：“当一个RAII对象被复制，会发生生么事？”大多情况下，会有两种选择：</p>
<ul>
<li>禁止复制。可以通过条款6的方式，将copying操作声明为private来禁止RAII对象被复制。</li>
<li>引用计数法。当希望保有资源，直到它的最后一个使用者被销毁时，复制RAII对象，应该将资源的“被引用数”递增，可以基于shared_ptr实现，而且可以通过其“删除器”指定当引用计数为0时的动作（对于mutex来说，引用为0时是unlock而不是删除）。</li>
<li>复制底部资源。不过这样的复制应该是深度拷贝，也就是创建资源的复件。</li>
<li>转移底部资源的拥有权。可以确保永远只有一个RAII对象指向一个资源。</li>
</ul>
<h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类将资源管理起来，也要提供相应的接口来提供对原始资源的访问。对于智能指针（例如 tr1::shared_ptr 和 auto_ptr）而言，有两种方式来获取原始资源：</p>
<ul>
<li><p>显式转换：智能指针中提供了一个<code>get</code>成员函数，可以返回智能指针内部的指向原始资源的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;           <span class="comment">// 函数原型，返回投资天数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.<span class="built_in">get</span>());              <span class="comment">// pInv.get()返回原始资源指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式转换：几乎所有智能指针都重载了指针取值操作符（operator-&gt; 和 operator*），允许隐式转换至底部原始指针。如果要直接获取原始资源，还可以重载operator()，但也会造成不小心错误转换的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// 一个成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;    <span class="comment">// factory函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>;     </span><br><span class="line"><span class="keyword">bool</span> taxable1 = !(pi1-&gt;isTaxFree());       <span class="comment">// 使用operator-&gt;隐式转换</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> taxable2 = !((*pi2).isTaxFree());     <span class="comment">// 使用operator*隐式转换</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一般来说，显式转换比较安全，而隐式转换对客户比较方便。</p>
<h3 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h3><p>考虑这样的行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *stringArray = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringArray;</span><br></pre></td></tr></table></figure>

<p>很明显，new的是一个100个string元素的数组，而delete仅正确删除了数组中的第一个对象，另外99个不太可能被正确删除，因为它们的析构函数没有被调用。</p>
<blockquote>
<p>关于new和delete：</p>
<p>使用new动态生成对象时，有两件事发生：（1）通过名为 operator new 的函数将内存分配出来；（2）针对此内存会有一个（或更多）构造函数被调用。</p>
<p>当使用delete时，也有两件事发生：（1）针对此内存有一个（或更多）析构函数被调用；（2）通过名为 operator delete 的函数释放内存。</p>
</blockquote>
<p>然而，delete的最大问题在于：即将被删除的内存之中究竟有多少对象？这关系到有多少个析构函数必须被调用。这个问题也可以简化为：即将被删除的指针，所指向的是单一对象还是对象数组？这是因为，数组所在的内存中通常还包括“数组大小”的记录，delete如果知道是数组，就能知道需要调用多少次析构函数。</p>
<p>所以，当你调用new时使用[ ]，就必须在对应调用delete时也使用[ ]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *stringPtr1 = <span class="keyword">new</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">string</span> *stringPtr2 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;</span><br></pre></td></tr></table></figure>



<h3 id="条款17：以独立语句将newed对象放入智能指针"><a href="#条款17：以独立语句将newed对象放入智能指针" class="headerlink" title="条款17：以独立语句将newed对象放入智能指针"></a>条款17：以独立语句将newed对象放入智能指针</h3><p>考虑这样的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>

<p><code>prcoessWidget</code>需要传入智能指针，就直接在传参时初始化了。但是令人惊讶的是，这样的调用可能会造成隐晦的资源泄露。这是因为调用processWidget前，编译器必须创建代码，做以下三件事：</p>
<p>（1）调用priority；（2）执行“new Widget”；（3）调用tr1::shared_ptr构造函数</p>
<p>但是，C++编译器以什么样的顺序执行这三个语句是不确定的（只能确定的是，（2）优先于（3）执行，但（1）可能排在1，2或3的次序来执行）。假设调用priority在第二步执行，万一priority的调用导致异常，那么“new Widget”返回的指针将会遗失，因为它还没有置入tr1: :shared_ptr中。</p>
<p>为避免这样的问题，<strong>应该使用分离语句，用独立的语句将newed对象置入智能指针中</strong>。否则，一旦异常被抛出，有可能导致难以察觉的资源泄露。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;    <span class="comment">// 独立语句</span></span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>



<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h3><p>想设计出一个“易用而不易出错的”接口，必须考虑客户可能出现什么样的错误。具体地，可以从两个方面着手改善：</p>
<ul>
<li><p>“促进正确使用”：包括接口一致性，以及与内置类型的行为兼容。</p>
</li>
<li><p>“阻止误用”：包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</p>
<p>例如，用一个class表示日期，考虑这样的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样有可能客户会不记得那个参数是月，而哪个是日，客户可能会迷糊。一个好的办法是引入外覆类型来区别天数、月份和年份，然后在Date构造函数中使用这些类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>/<span class="title">Month</span>/<span class="title">Year</span>&#123;</span></span><br><span class="line">	<span class="keyword">explicit</span> Day/Month/Year(<span class="keyword">int</span> x):val(x)&#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">1</span>), Day(<span class="number">7</span>), Year(<span class="number">2023</span>))</span></span>;    <span class="comment">// 这样调用更加明确，错误的类型将导致异常，防止接口被误用</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h3><p>如何设计高效的class，需要面对以下的问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？创建销毁是单一对象还是数组。</li>
<li>对象的初始化和赋值有什么样的差异？</li>
<li>什么是新type的”合法值“？这意味着它的成员函数必须错误检查工作，以及考虑可能抛出的异常。</li>
<li>新的type需要配合某个继承体系吗？特别是受到”它们的函数是virtual还是non-virtual“的影响。</li>
<li>新的type需要什么样的转换？涉及到类型转换。</li>
<li>什么样的操作符和函数对此新type而言是合理的？这会决定你将为该class声明哪些函数。</li>
<li>什么样的标准函数应该被驳回？哪些函数（包括编译器自动创建的）应该被声明为private。</li>
<li>谁该取用新type的成员？这个问题将决定哪个成员为public，哪个为protected，哪个为private。</li>
<li>你的新type有多么一般化？如果足够一般化，就应该定义一个新的class template。</li>
<li>你真的需要一个新的type吗？</li>
</ul>
<h3 id="条款20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><p>缺省情况下，C++以 by value 方式传递对象至函数，<u>函数参数以实际参数的复件为初值，而调用端所获得的也是函数返回值的一个复件</u>。这些复件是由对象的<em>copy构造函数</em>产出的，这使得 pass-by-value 成为昂贵的（费时的）操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass-by-value</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validStudent</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.getSchoolName() == <span class="string">"HUST"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pass-by-reference-to-const</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validStudentRef</span><span class="params">(<span class="keyword">const</span> Student&amp; cs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getSchoolName() == <span class="string">"HUST"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，在C++中有以下三种情况需要调用拷贝构造函数：</p>
<ol>
<li>一个对象作为函数参数，以值传递的方式传入函数体；</li>
<li>一个对象作为返回值，以值传递的方式从函数返回；</li>
<li>一个对象用于给另一个对象进行初始化。</li>
</ol>
<p>另一方面，<strong>pass-by-reference</strong>-to-const 这种方式就高效得多：没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。其中的const声明也是很重要的，这样就不用担心调用者会对传入的对象进行修改，除非确实需要修改才不加const。</p>
<p>而且，<strong>pass-by-reference</strong>-to-const 还有一个好处是：可以避免对象切割（slicing）的问题。下面作为一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">// 返回窗口名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 返回窗口和其内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWithScrollBars</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 带滑动条的窗口展示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>display</code> 是一个虚函数，这意味着两种窗口的展示方式会不同。现在假设你希望写一个函数打印窗口名称并显示该窗口，如果这么写将是一个错误的示范：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWindow</span><span class="params">(Window w)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; w.name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用以上函数，并传递一个 WindowWithScrollBars 对象时，参数w会被构造成一个Window对象，而所有 WindowWithScrollBars 对象所特有的信息将会被切除。</p>
<p>解决对象切割（slicing）问题的办法就是，以 <strong>pass-by-reference</strong>-to-const 的方式传递w：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWindow</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span></span>&#123;    <span class="comment">// 引用传递，对象参数不会被切割</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; w.name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 reference 往往以指针实现，这意味着 pass-by-reference 真正传递的是指针（引用是别名形式，不过其内涵仍是指针）。所以，传进来的窗口是什么类型，w就表现的是哪种类型。</p>
<p>不过，虽然 <strong>pass-by-reference</strong>-to-const 更加高效，且能够避免对象切割的问题。但是，这种规则并不适用于内置类型，以及STL的迭代器和函数对象，对它们而言，pass-by-value 往往比较合适。</p>
<h3 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h3><p>领悟到了 pass-by-reference-to-const 的高效后，如果一味执着地追求，那么一定会犯下一个致命错误：<strong>传递一些references指向其实并不存在的对象</strong>。</p>
<p>在函数返回时，一定要注意以下三点：</p>
<ol>
<li><p>绝不要返回指向一个 local stack 对象的 pointer 或者 reference。这很容易理解，本地栈对象离开函数体就销毁了。</p>
</li>
<li><p>不要返回指向一个 heap-allocated 对象的reference。</p>
<p>返回堆对象的引用，那么谁去负责它的资源释放呢？对于外层看来就是一个对象，客户大概率不会想到去释放这部分资源（或者说，释放一个看似普通对象而非指针是比较迷惑的），若不处理，则必然都是内存泄露。比如释放堆对象的引用就需要这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">const</span> Student&amp; <span class="title">clonedStudent</span><span class="params">(<span class="keyword">const</span> Student&amp; cs)</span></span>&#123;    <span class="comment">// 返回堆对象的引用</span></span><br><span class="line">    Student *clone_s = <span class="keyword">new</span> Student(cs);</span><br><span class="line">    <span class="keyword">return</span> *clone_s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">delete</span> &amp;<span class="title">clonedStudent</span><span class="params">(wlz)</span></span>;    <span class="comment">// 释放资源</span></span><br></pre></td></tr></table></figure>

<p>当然，返回堆对象的指针也需要很好的资源管理，但至少对于客户来说，能够清晰地知道 “这个指针指向了一部分资源，需要进行管理”。</p>
</li>
<li><p>不要返回 pointer 或者 reference 指向一个 local static 对象而可能同时需要多个这样的对象。这会在多线程中出现安全性问题。</p>
</li>
</ol>
<p>同时，结合到条款10，应该得到这样的结论：</p>
<ul>
<li>class中不需要产生新对象的操作，例如重载赋值型操作（=，-=，+=，*=等等），应返回 reference to *this。因为赋值函数不用产生新对象，而引用的返回可以保证“连锁赋值”操作。</li>
<li>对于需要产生新对象的函数，遵守上述三条规则。例如class中的运算操作（*，+等）。</li>
</ul>
<h3 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h3><p>仅记住两点即可：</p>
<ul>
<li>切记将成员变量声明为 private 。这可以赋予客户访问数据的一致性（public全为接口）、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected 并不比 public 更具封装性。</li>
</ul>
<h3 id="条款23：宁以-non-member、non-friend-替换-member-函数"><a href="#条款23：宁以-non-member、non-friend-替换-member-函数" class="headerlink" title="条款23：宁以 non-member、non-friend 替换 member 函数"></a>条款23：宁以 non-member、non-friend 替换 member 函数</h3><p>考虑用一个class来表示网页浏览器。在class可能提供的众多函数中，有一些用来清除下载元素高速缓冲区、清除访问过的URLs、以及移除系统中所有的cookies：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>许多用户会想，再建立一个功能来一整个执行所有的清除动作，因此这个类还可以提供一个这样的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">()</span></span>;        <span class="comment">// 调用以上3个清除成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者，这一功能也可以由一个 non-member 函数调用适当的 member 函数来完成，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.removeCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这两种实现，哪一个更好呢？</p>
<p>事实是，使用 non-member，non-friend 函数代替 member 函数会更好，这样能够提高封装性（它不增加“能够访问class内private部分”的函数数量）、包裹弹性和机能扩充性。</p>
<h3 id="条款24：若所有参数都需类型转换，请为此采用-non-member-函数"><a href="#条款24：若所有参数都需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款24：若所有参数都需类型转换，请为此采用 non-member 函数"></a>条款24：若所有参数都需类型转换，请为此采用 non-member 函数</h3><p>让class支持隐式类型转换通常是一个糟糕的主意，但是也有意外，比如在建立数值类型时。假设设计了一个class用来表示有理数，那么允许整数“隐式转换”为有理数是合理的。假如这样开始了“有理数”类的构建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>);  <span class="comment">// 构造函数刻意不加explicit,以允许隐式类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 访问分子</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 访问分母</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，想要支持算术运算符（如+，*等），但不确定该由 member 函数、non-member 函数，或者 non-member friend 函数来实现时，应该保持面向对象的精神。实现乘法与有理数有关，所以应该在类中成员函数为有理数实现 operator*。比如，这么实现了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式可以应对两个有理数的相乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEight;    <span class="comment">// 正确</span></span><br><span class="line">result = result * oneHalf;               <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>但是，当进行混合运算时，比如用有理数与int进行相乘，却只有一半能行得通：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;        <span class="comment">// (1)正确， oneHalf.operator*(2), 2会隐式转换为Rational</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;        <span class="comment">// (2)错误， 2.operator*(oneHalf)，整数2并不是Rational，也不支持这样的混合运算</span></span><br></pre></td></tr></table></figure>

<p>我们尝试找出（1）之所以成功的原因，oneHalf调用operator*，而参数是2，编译器知道函数需要的是Rational，而由于Rational的构造函数并没有explicit，所以可以将int隐式转换到Rational。</p>
<blockquote>
<p>这样得出的一个结论是：只有当参数被列于参数列（parameter list）内，这个参数才是隐式类型转换的合格参与者。</p>
</blockquote>
<p>那么让Rational进行混合运算的方法也拨云见日了，即：<strong>让operator*成为一个 non-member 函数，接受所有运算符的参与者，以允许编译器在任何一个实参上执行隐式类型转换</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">    ...                <span class="comment">// operator* 不再作为成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(), </span><br><span class="line">                   lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneHalf;     <span class="comment">// 这两个都没有问题了</span></span><br></pre></td></tr></table></figure>

<p>如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个 non-member 函数。</p>
<h3 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款25：考虑写出一个不抛异常的swap函数</h3><p>swap是一个有趣的函数。它原来只是STL的一部分，后来成为异常安全性编程（条款29）的脊柱，以及用来处理自我赋值（条款11）可能性的一个常见机制。swap的典型实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要类型T支持copying（copy构造和copy赋值操作符），swap就会帮你完成置换的操作。不过这样的实现对于“pimpl手法”来说是没有必要的。所谓“pimpl手法”指的是：“以指针指向一个对象，内含真正数据”的类型。比如用这种方式来设计Widget，那么就会是这个样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span>    <span class="comment">// Implment类，包含真正数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;    <span class="comment">// 假如有很多数据，那么要复制的话就要很久</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;   <span class="comment">// Impl指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当需要交换Widget对象时，实际上只要交换它们的 Impl 指针就可以了，但是上述实现的典型swap并不知道。这样的话，swap不仅会复制3个Widget，还有3个WidgetImpl对象，这样的效率比较低。我们希望告诉swap，置换Widget时，其实只需要置换内部的Impl指针即可。</p>
<p>（书中这段讲的感觉有点乱，需要消化一下）</p>
<p>这里直接上结论：</p>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于class（而非template），需要特化std::swap。</li>
<li>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</li>
<li>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h3><p>只要你定义了一个变量而其类型具有一个构造函数或析构函数，那么就得承受它带来的构造和析构成本。即使这个变量最终并未使用，仍需耗费这些成本，所以应该尽可能避免这种情形。</p>
<p>考虑这样的情景：一个函数计算通行密码的加密版本然后返回，前提是密码足够长；如果密码太短，函数就会丢出一个异常，类型为logic_error。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    <span class="keyword">if</span>(password.length() &lt; MinimumPasswordLength)&#123;</span><br><span class="line">		<span class="keyword">throw</span> logic_error(<span class="string">"Password is too short."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...       <span class="comment">// 必要动作，将加密后的密码置入 encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么情况就是，如果有个异常被丢出，对象encrypted就没有用，但仍得付出encrypted的构造和析构成本，所以最好<u>延后encrypted的定义式，直到确实需要它</u>。进一步地，应该<u>尝试延后这份定义直到能够给它初值为止</u>，这样可以避免无意义的default构造行为（“默认构造后再赋值”比“直接在构造的时候指定初值”效率低）。这样可以增加程序的清晰度，并改善程序效率。</p>
<h3 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h3><p>转型通常可能导致种种麻烦，有些容易识别，有些则非常隐晦。然而，在C++中转型是一个你会想带着极大尊重去亲近的一个特性。</p>
<p>来回顾一下转型语法，可以分为“旧式转型”和“新式转型”两种：</p>
<p><strong>“旧式转型”</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)expression    <span class="comment">// C风格的转型</span></span><br><span class="line">T(expression)    <span class="comment">// 函数风格的转型</span></span><br></pre></td></tr></table></figure>

<p><strong>“新式转型”</strong>：指C++提供的四种新式转型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure>

<ul>
<li>const_cast 通常被用来将对象的常量性转除（cast away the constness）。它也是唯一有此能力的C++style转型操作符。</li>
<li>dynamic_cast 主要用来执行“安全向下转型（safe downcasting）”，也就是用来决定对象是否归属继承体系中的某个类型。</li>
<li>reinterpret_cast 意图执行低级转型，实际动作（及结果）可能取决于编译器，这也代表它不可移植。例如将一个 pointer to int 转型为一个 int，这类转型在低级代码以外非常少见。</li>
<li>static_cast 用来强迫隐式转换（implicit conversion），例如将 non-const 对象转换为 const 对象，将 int 转换为 double 等。它也可以用来执行上述多种转换的反向转换，例如将 void* 指针转换为 typed 指针，将 pointer-to-base 转换为 pointer-to-derived。但是它无法将 const 转换为 non-const ，这个只有const_cast能够做到。</li>
</ul>
<p>许多人认为转型只是告诉编译器把某种类型视为另一种类型。这是错误的观念，其实任何一个类型转换往往会令编译器编译出运行期间执行的码，因为不同类型的底层实现是不同的。</p>
<p>而且因为转型，我们很容易写出似是而非的代码。例如许多应用框架都要求derived class内的virtual函数代码第一个动作就先调用base class的对应函数。假设这么进行了实现，它看起来对，但实际上错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123; ... &#125;    <span class="comment">// base class 中的实现代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize();    <span class="comment">// 想要通过转型调用基类的onResize函数</span></span><br><span class="line">        ...                    <span class="comment">// 执行SpecialWindow内的专属动作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段程序将<code>*this</code>转型为<code>Window</code>，对函数onResize的调用也因此调用了Window::onResize。但恐怕你没有想到，这样调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象的base class成分”的暂时副本身上的onResize. 换句话来说就是，它在“当前对象的base class成分”的副本上调用Window::onResize，然后在当前对象身上执行SpecialWindow的专属动作。</p>
<p>如果Window::onResize修改了对象内容（也有可能，因为onResize此时是一个non-const成员函数），就会使得当前对象进入到一个“伤残”状态：其 base class 成分的更改没有落实，而 derived class 成分的更改落实了。</p>
<p>解决方法就是拿掉转型动作，取而代之的是你真正想要表达的：令base class的onResize函数作用到当前对象的身上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Window::onResize();     <span class="comment">// 调用Window::onResize作用在*this身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子也说明，如果你发现自己打算转型，这可能就是一个警告⚠：可能会发生错误。</p>
<p>如果使用的是 dynamic_cast 就更是如此。而且 dynamic_cast 的许多实现版本执行速度相当慢，深度继承或者多重继承时，它的成本更高。</p>
<p>之所以需要dynamic_cast，通常是因为想在一个认定为 derived class 对象身上执行 derived class 操作函数，但是手上却只有一个“指向 base”的pointer或reference，只能靠它们来处理对象。有两个一般性方法可以避免这个问题：</p>
<ol>
<li><p>使用容器，并在其中存储直接指向 derived class 对象的指针（通常是智能指针，以管理资源）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt; tr1::<span class="built_in">shared_ptr</span>&lt;SpecialWidon&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>() ++iter)&#123;</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种做法无法在同一容器中存储“所有Window派生类的指针”。如果要处理多种窗口类型，可能需要多个容器，都必须具备类型安全性。</p>
</li>
<li><p>在 base class 内提供virtual函数做你想对各个派生类做的事。例如，虽然只有SpeicalWindow可以闪烁，但将闪烁函数声明于base class内，并提供一份”什么也没做“的缺省实现码也是有意义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">// 缺省实现代码“什么也没做”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>&#123; ... &#125;   <span class="comment">// 在该类内 blink 进行一些动作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt; tr1::<span class="built_in">shared_ptr</span>&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结一下，本条款需要注意的就是：如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast ，如果有个设计需要转型，试着发展无需转型的替代设计；如果转型是必要的，试着将其隐匿在某个函数后，而不需要客户将转型放到自己的代码中。宁可使用新型转型，不要使用旧式转型，前者更容易分辨且有分门别类的职掌。</p>
<h3 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h3><p>考虑这样的程序设计，每个矩形由左上角和右上角表示。为了让Rectangle对象尽可能小，会将其放到一个辅助的struct内，再让Rectangle指向它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span>&#123;</span></span><br><span class="line">    Point ulhc;         <span class="comment">// 左上角</span></span><br><span class="line">    Point lrhc;         <span class="comment">// 右下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Rectangle要返回左上角和右下角的数据给客户，而为了提高效率返回了Point引用。这样虽然能够通过编译，确实自我矛盾的，因为Point本应该是内部私有数据，但是经由public函数返回了引用，这样Point对于客户相当于是public的了，可以通过引用来更改内部数据。</p>
<p>这给我们带来两个教训：</p>
<ul>
<li>成员变量的封装性最多只等于“返回其reference”的函数的访问级别；</li>
<li>如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数调用者就能够修改那笔数据。</li>
</ul>
<p>一般地，如果成员函数返回指针或者迭代器，情况也是一样的。Reference, 指针和迭代器都是所谓的“handles”（号码牌，用来获取某个对象），返回一个“代表对象内部数据”的handle，随之而来的就是“降低对象封装性”的风险。</p>
<p>其实对于上述矩形例子的情况，对返回值加上const就能够保证内部数据不被外部修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br></pre></td></tr></table></figure>

<p>尽管如此，返回“代表内部对象的handles”也可能在其他场合带来问题，即可能导致dangling handles（空悬的号码牌）：handles所指东西不复存在。</p>
<p>种种，并不代表你绝不可以让成员函数返回handles。但是，尽量避免返回handles指向对象内部，可以增加封装性，帮助const成员函数的行为像个const，并将发生“空悬号码牌”的可能性降到最低。</p>
<h3 id="条款29：为“”异常安全“而努力是值得的"><a href="#条款29：为“”异常安全“而努力是值得的" class="headerlink" title="条款29：为“”异常安全“而努力是值得的"></a>条款29：为“”异常安全“而努力是值得的</h3><p>假设有一个class用来表现带背景图案的GUI菜单，同时这个class希望用于多线程环境，所以它配有一个互斥器（mutex）作为并发控制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>;       <span class="comment">// 改变背景图像</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;       <span class="comment">// 互斥器</span></span><br><span class="line">    Image* bgImage;    <span class="comment">// 目前的背景图像</span></span><br><span class="line">    <span class="keyword">int</span> imageChanges;  <span class="comment">// 背景图像被改变的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变背景图像的一种可能的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">	lock(&amp;mutex);                    <span class="comment">// 取得互斥器</span></span><br><span class="line">    <span class="keyword">delete</span> bgImage;                  <span class="comment">// 撤销旧的背景图像</span></span><br><span class="line">    ++imageChanges;                  <span class="comment">// 修改图像变更次数</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);     <span class="comment">// 配置新的背景图像</span></span><br><span class="line">    unlock(&amp;mutex);                  <span class="comment">// 释放互斥器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数仅仅完成了“基础功能”，但是从“<strong>异常安全性</strong>”的观点来看，却实现的非常糟糕。所谓“异常安全”有两个条件，而这个函数并没有满足其中任何一个。考虑到当异常被抛出时，带有异常安全性的函数往往会：</p>
<ol>
<li><strong>不泄露任何资源</strong>。上述代码没有做到，因为一旦“new Image()”导致了异常，那么unlock就不会调用，于是互斥器就永远被锁住了。</li>
<li><strong>不允许数据破坏</strong>。如果“new Image()”抛出异常，那么<code>bgImage</code>就会指向一个已被删除的对象，而且<code>imageChanges</code>也被累加，但是实际上并没有新的图像被安装应用。</li>
</ol>
<p>对于“资源泄露”，第三章已经介绍了很多方法，这里对于非heap-based的mutex，可以借鉴条款14引入的Lock类进行互斥器资源管理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">	<span class="function">Lock <span class="title">myLock</span><span class="params">(&amp;mutex)</span></span>;       <span class="comment">// 自定义资源管理类，获取互斥器并保证稍后得到释放</span></span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决了第一个问题，就可以专注于如何处理可能的数据破坏了。<u>异常安全函数</u>（Exception-safe functions）提供以下三个保证之一：</p>
<ul>
<li><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下，不会有任何数据被破坏。但是唯一的问题就是程序的现实状态可能无法预测，例如更换背景的函数，异常抛出后回到之前的状态或者默认的状态都是有效的。</li>
<li><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。这意味着如果函数失败，程序会回复到“调用函数之前”的状态。</li>
<li><strong>不抛掷（nothrow）保证</strong>：承诺绝不抛出异常，因为它们总能够完成承诺的功能。例如，作用在内置类型（ints, 指针等）身上的所有操作都提供nothrow保证。</li>
</ul>
<p>对于大部分函数而言，考虑异常安全会在基本保证和强烈保证中进行抉择。至于changeBackground来说，提供强烈保证并不困难：（1）改变PrettyMenu的bgImage成员变量的类型，从Image*指针改为一个“用于资源管理”的指针，使用std::tr1::shared_ptr。（2）对语句重新排序，当更换背景图像之后，在累加imageChanges变量。改变结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">myLock</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.reset(<span class="keyword">new</span> Image(imgSrc));    <span class="comment">// 以"new Image"的执行结果设定bgImage内部指针</span></span><br><span class="line">    ++imageChanges; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个修改足以为changeBackground函数提供异常安全保证，唯一美中不足的就是参数imgSrc，如果输入流参数被移走，那么就会导致Image构造函数抛出异常。</p>
<p>注意，这里不再需要手动delete旧图像，因为这个动作在智能指针内部处理掉了，当新的背景图像创建成功后，智能指针更换指向前，就会自动释放旧的背景图像。</p>
<p>一般地，有个<em>经典的策略也能够承诺强烈保证</em>，即：<strong>copy and swap</strong>. </p>
<blockquote>
<p>原则很简单：给你打算修改的对象（原件）做出一份副本，然后在那个副本身上做一切必要的修改。若有任何修改抛出异常，原对象仍保持不变。等所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。</p>
</blockquote>
<p>copy and swap在实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个实现对象，这种手法也就是所谓的”pimpl”，对于PrettyMenu而言，典型的写法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">myLock</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    swap(pImpl, pNew);            <span class="comment">// 置换实现对象，自动释放mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，之所以让PMImpl成为一个struct而不是一个class，是因为PrettyMenu的数据封装性已经由“pImpl是一个private成员”而得到了保证。</p>
<p>当然，有的时候某些原因必然会阻止你为函数提供强烈保证，其中一个就是效率。copy-and-swap的关键在于“修改对象数据的副本，然后在一个不抛出异常的函数中将修改后的副本与原件置换”，而为原有对象做出副本，就得消耗一定的时间和空间成本。当你无法提供这样的成本时，强烈保证就不那么实际了，这时就必须提供基本保证。</p>
<h3 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h3><p>inline函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。</p>
<p>但是，过于热衷inlining也会导致：增加目标码（object code）的大小，代码膨胀导致额外的换页行为，降低告诉缓存装置的命中率，以及伴随而来的效率损失。不过，如果inline函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小，从而提高效率。</p>
<p>inline只是对编译器的一个申请，不是强制命令。而且这项申请既可以明确提出，也可以隐喻提出：</p>
<ul>
<li><p>明确提出，用inline关键字加以修饰。例如，标准的max template:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐喻提出，该方式是将函数定义在class的定义式内。即，类内定义的成员函数已被隐含地指定为Inline函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;      <span class="comment">// age其实被隐含指定为inline</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;             <span class="comment">// 在类外定义，如需内联需明确提出为inline</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> theAge;</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">Person::name</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但要注意的是，如果类的成员函数在类内声明，而在类外定义，那么编译器并不认为它是一个内联函数（例如Person::name）。所以建议就是不要在类中编写大量的代码，而是应该将类的声明和定义分开，只有成员规模小且调用频率高时，才指定为inline函数。</p>
</li>
</ul>
<h3 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h3><p>C++项目代码应该做到“接口与实现分离”，而其关键在于“以声明的依存性”替换“定义的依存性”。这也是<em>编译依存性最小化</em>的本质——<u>程序头文件应该以“完全且仅有声明式”的形式存在</u>：头文件自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p>
<p>令编译依存性最小化，可以源于以下的设计策略：</p>
<ul>
<li><p><strong>如果使用 object reference 或 object pointers 可以完成任务，就不要使用 objects</strong>。你可以只靠一个类型声明式就定义出指向该类型的references和pointers；但如果定义某类型的objects，就需要用到该类型的定义式。例如以下写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;                   <span class="comment">// 定义一个int</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">( params )</span></span>;      <span class="comment">// （1）定义一个Person</span></span><br><span class="line">    Person *p;               <span class="comment">// 定义一个Person指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器看到p的定义式（1）时，它要知道应该在stack中分配多少空间才能放置一个Person，于是就会询问class定义式。而如果时定义式（2），那么对class Person的任何实现上的修改都不需要Person客户端重新编译了。</p>
</li>
<li><p><strong>如果能够，尽量以class声明式替换class定义式</strong>。值得注意的是，当你声明一个函数而它用到某个class时，你并不需要该class的定义，纵使函数以by value方式传递该类型的参数（或返回值）也是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>                       <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                     <span class="comment">// 声明函数，返回Date对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;   <span class="comment">// 声明函数，参数为Date对象</span></span><br></pre></td></tr></table></figure>

<p>声明<code>today</code>和<code>clearAppointments</code>函数时是不需要Date类型的定义式的。只有当有人需要调用这些函数时，调用之前才需要曝光Date的定义式。</p>
</li>
<li><p><strong>为声明式和定义式提供不同的头文件</strong>。为了促进严守上述准则，需要两个头文件，一个用于声明式，一个用于定义式。当然，这些文件必须保持一致性。举个例子，如果客户想要声明today和clearAppointments函数，那么不应该以手工前置的方式声明Date类型，而是应该#include适当含有声明的头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"datefwd.h"</span>     <span class="comment">// 该头文件内声明（而未定义）class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个致函声明式的头文件名为“datefwd.h”，命名方式同于标准程序库头文件的&lt;iosfwd&gt;, &lt;iosfwd&gt;内含iostream各组件的声明式，其对应的定义式则分布在若干不同的头文件中。</p>
</li>
</ul>
<p>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。而<u>基于此构想的两个手段是 Handle class 和 Interface class</u>. </p>
<ul>
<li><p><strong>Handle class</strong>: 将所有函数转交给相应的实现类并由后者完成实际工作，也就是 “pointer to implementation”的手法，例如下面是Person两个成员函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span>        <span class="comment">// 包含Person定义式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PersonImpl.h"</span>    <span class="comment">// 包含PersonImpl定义式</span></span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr):pImpl(<span class="keyword">new</span> PersonImpl(name, birthday, addr))&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Person::name</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际工作是由其实现类完成的。</p>
</li>
<li><p><strong>Interface class</strong>: 仅作为描述derived class的接口，不携带成员变量，也没有构造函数，只有一个virtual析构函数以及一组 pure virtual 函数，用来叙述整个接口。例如，一个针对Person而写的 Interface class 看起来会是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Interface class 的客户同时必须有办法为这种class创建对象，这通常需要工厂（factory）函数或者virtual构造函数，它们返回指针（或更为可取的智能指针），指向动态分配的对象，而该对象支持 Interface class 的接口。<strong>这样的函数往往在 Interface class 内被声明为static</strong>。</p>
<blockquote>
<p>static成员函数，不会获得对象的引用，也不能访问对象的非static成员。函数调用的结果不访问或者修改任何对象（非static）数据成员，那么将这样的成员函数声明为static成员函数比较好。</p>
</blockquote>
<p>例如，Person可能提供如下工厂函数，以让客户获取真正的Person对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// create工厂函数返回一个shared_ptr，指向一个真实的Person派生类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员函数——工厂函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">    <span class="comment">// 这里也需要RealPerson的声明，可以构建一个personpwd.h头文件，包含各种定义式的声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个具象的Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr):theName(name), theBirthDate(birthday),theAddress(addr)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson&#123;&#125;</span><br><span class="line">    <span class="comment">// 下列函数的实现码不在这里显示</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户可能会这么使用</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line"><span class="comment">// 创建一个对象，支持Person接口。调用static函数create，拷贝构造shared_ptr。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line"><span class="comment">// 通过Person接口来使用这个对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; pp-&gt;name() &lt;&lt; <span class="string">"was born on "</span> &lt;&lt; pp-&gt;birthDate() &lt;&lt; <span class="string">" and now lives at "</span> &lt;&lt; pp-&gt;address() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 离开作用域后，该对象会由智能指针自动销毁</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意，如果只因为若干额外成本便不考虑Handle class 和 Interface class，那么将是严重的错误。应该考虑以渐进的方式使用这些技术。在程序发展过程中使用 Handle class 和 Interface class 以求实现码有所变化时对其客户带来最小冲击。而当它们导致速度和/或大小差异过于重大以至于classes之间的耦合相形之下不成为关键时，就以具象类（concrete class）替换Handle class 和 Interface class.</p>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款32：确定你的public继承塑模出-is-a-关系"><a href="#条款32：确定你的public继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的public继承塑模出 is-a 关系"></a>条款32：确定你的public继承塑模出 is-a 关系</h3><p>纵使你会忘记其他的每一件事，也要记住为数不多的重要的事情。以C++进行面向对象编程，最重要的一个规则是：<strong>public inheritance（公开继承）意味 “is-a” 的关系</strong>。</p>
<p>如果令class D（”Derived”）以public形式继承class B（”Base”），这就意味着，<strong>每一个D类型的对象同时也是一个B类型的对象，而反之不成立</strong>。B是比D更一般化的概念，D属于B。</p>
<p>public继承和 is-a 之间的等价关系听起来简单，但在一些现实情况中，你的直觉可能会误导你。例如，企鹅🐧是一种鸟，这是事实；而鸟可以飞，这也是事实。但如果用public继承来表述这层关系，那么企鹅应该会有能够飞的功能，这与现实又是违背的。其原因在于，我们的描述并不严谨，应该要承认一个前提事实：有些鸟并不会飞。那么应该这样写出继承关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>&#123;</span></span><br><span class="line">    ...         <span class="comment">// 没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span>:</span> <span class="keyword">public</span> Bird&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span>:</span> <span class="keyword">public</span> Bird&#123;</span><br><span class="line">    ...          <span class="comment">// 继承Bird，并没有声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p> 我们知道，对于同一名称而言，<em>局部作用域中的名称会覆盖全局作用域的相同名称</em>。</p>
<p>对于继承而说，derived class 作用域被嵌套在 base class 作用域内，同时“名称可见性”与上述相同：<strong>derived class 内的名称会掩盖 base class 内的名称</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数mf1</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">// 虚函数mf1的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;       <span class="comment">// 虚函数mf2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;               <span class="comment">// 重载mf3，两个都是非虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码带来的行为是诡异的。以作用域为基础的“名称遮掩规则”并没有改变，所以 base class 内所有名为mf1和mf3的函数都被 derived class 内的mf1和mf3掩盖掉了。于是，客户的某些调用将会出现错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1();        <span class="comment">// 调用Derived::mf1</span></span><br><span class="line">d.mf1(x);       <span class="comment">// 错误！因为Derived::mf1掩盖了Base::mf1</span></span><br><span class="line">d.mf3();        <span class="comment">// 正确</span></span><br><span class="line">d.mf3(x);       <span class="comment">// 错误，同上</span></span><br></pre></td></tr></table></figure>

<p>可见，<u>不论 base class 和 derived class 内的同名函数是否有不同的参数类型、是否为virtual函数，其名称掩盖规则都是适用的</u>。那么这样就会引出两种情况：</p>
<ul>
<li><p><strong>想要继承 base class 并加上重载函数</strong>：那么必须为那些原本会被遮掩的每个名称<em>引入一个using声明式</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;      <span class="comment">// 让Base class内名为mf1和mf3的所有东西在Derived作用域中都可见（且public）</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样声明之后，客户再调用不同形式的mf1和mf3都是可行的了。</p>
</li>
<li><p><strong>不想继承Base class中的所有函数</strong>：例如只想继承无参版本的mf1。当然，这在public继承中是绝对不可能发生的，这违反了“is-a”的关系。但是这在private继承中是有意义的，这需要一个<strong>转交函数（forwarding function）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;    <span class="comment">// 转交函数</span></span><br><span class="line">        Base::mf1();       <span class="comment">// 注意，这个类内定义的成员函数也是默认为inline的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">d.mf1();        <span class="comment">// 正确，调用Derived::mf1，但是转交给了Base::mf1()处理</span></span><br><span class="line">d.mf1(x);       <span class="comment">// 错误！Base::mf1有参版本被遮掩了</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p>表面上直接了当的public继承概念，实际上由两部分组成：<u>函数接口继承</u> 和 <u>函数实现继承</u>。作为class的设计者，可能会面临以下情况：</p>
<ul>
<li>希望 derived class 只继承成员函数的接口（即声明）；</li>
<li>希望 derived class 同时继承函数的接口和实现，但又希望能够覆写（override）它们所继承的实现；</li>
<li>希望 derived class 同时继承函数的接口和实现，并且不允许覆写任何东西。</li>
</ul>
<p>为清楚地感觉上述选择的差异，考虑以下的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>Shape是一个抽象类，而且强烈影响了所有以public形式继承它的 derived class，因为：</p>
<ul>
<li><p>成员函数的接口总会被继承。例如Shape中的纯虚函数具备两个特征：在抽象类中通常没有定义，且必须被任何“继承了它们”的具象类重新声明。</p>
</li>
<li><p>声明一个纯虚函数，是为了让 derived class <u>只继承函数接口</u>。</p>
<p>纯虚函数draw的声明要求Shape的具象类必须提供一个draw函数，而不管如何被实现的。不过，令人意外的是，我们可以为 pure virtual 函数提供定义，但调用它的唯一途径是“调用时明确指出其class名称”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Ellipse;</span><br><span class="line">ps-&gt;draw();             <span class="comment">// 调用 Ellipse::draw</span></span><br><span class="line">ps-&gt;Shape::draw();      <span class="comment">// 调用 Shape::draw</span></span><br></pre></td></tr></table></figure>

<p>一般而言，这种性质的用途有限，但是它可以实现一种机制：<em>为（非纯）impure virtual 函数提供更一般更安全的缺省实现</em>。</p>
</li>
<li><p>声明（非纯）impure 的虚函数，是为了让 derived class <u>继承该函数的接口和缺省实现</u>。</p>
<p>例如Shape中的error函数，它表示每个class都必须支持一个“当遇到错误可以调用的”函数，每个class可以自由处理错误；但如果class不想对错误做出任何特殊处理，也可以回到Shape提供的缺省错误处理行为。</p>
<p>不过，这样的缺省实现也有可能造成隐患：<strong>当派生类中某些可以支持缺省实现，而派生类的另一些必须特化实现时</strong>。例如，model A飞机的fly函数可以缺省实现，但是model B飞机的飞行方式与A不同，不能利用缺省fly来实现。这个时候通常有两种方式来切断“virtual函数接口”与“缺省实现”之间的关系：</p>
<ol>
<li><p><strong>将 impure 虚函数更改为纯虚函数，并提供一份 protected non-virtual 的缺省实现</strong>。支持缺省实现的派生类继承该接口并以缺省实现实施，必须特化的派生类可以实现纯虚函数进行特殊处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ...   <span class="comment">// 缺省行为，飞到目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">        defaultFly(destination);    <span class="comment">// 缺省实现，以inline函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelB::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123; ... &#125;   <span class="comment">// 将ModelB飞向目的地</span></span><br></pre></td></tr></table></figure>

<p>其中，defaultFly为protected且non-virtual，因为客户不用知道飞机如何飞的，而且缺省实现也不应该被任何一个derived class 重新定义，故不需要virtual。但有些人反对这种方式，是考虑到这样对class的命名空间进行了污染（提供了函数接口和缺省实现）。那么下面的方式就会解除这样的名称污染问题。</p>
</li>
<li><p><strong>将 impure 虚函数更改为纯虚函数，为该纯虚函数提供定义以作为缺省实现，但调用时注意要指明class的名称</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;    <span class="comment">// 作为纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为，飞向目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span></span>&#123;</span><br><span class="line">        Airplane::fly(destination);      <span class="comment">// 缺省实现，inline</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelB::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123; ... &#125;   <span class="comment">// 将ModelB飞向目的地</span></span><br></pre></td></tr></table></figure>

<p>这样相当于合并了fly和defaultFly两个函数，不过丧失了“让两个函数享有不同保护级别”的机会。</p>
</li>
</ol>
</li>
<li><p>声明 non-virtual 函数，是为了让 derived class 继承接口以及一份强制性实现。Base class 的成员函数为non-virutal表明它不打算在 derived class 中有不同的行为。实际上，一个non-virtual成员函数所表现的不变性（invariant）凌驾其特异性（specialization）。</p>
</li>
</ul>
<p>pure virtual函数，impure virtual函数，non-virutal函数之间的差异，使你得以精确指定你想要 derived class 继承的东西：只继承接口，或是继承接口和一份缺省实现，或是继承接口和一份强制实现。</p>
<h3 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h3><p> 假设你在游戏设计中提供一个函数 healthValue，它返回一个整数，表示角色的健康程度。由于不同人物可能以不同方式计算其健康指数，因此将 healthValue 声明为一个 virtual 是一个再明白不过的做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 healthValue 并未声明为 pure virtual，这暗示着将会有一个计算健康程度的缺省实现。</p>
<p>不过，也可以考虑其他替代方案，能够帮助自己跳脱面向对象设计的常轨道：</p>
<ul>
<li><p><strong>通过 Non-Virtual Interface 手法实现 Template Method 模式</strong>：</p>
<p>该流派主张任何 virtual 函数应该几乎总是 private。于是较好的做法就是：保留 healthValue 为public成员函数，但让它成为 non-virtual，并调用一个 private virtual 函数（例如，doHealthValue）进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        ...                                <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="keyword">int</span> retVal = doHealthValue();      <span class="comment">// 做真正的事情</span></span><br><span class="line">        ...                                <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        ...                                <span class="comment">// 缺省算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码中，两个在类内定义的函数都被暗自实现为 inline。让客户“通过 public non-virtual 成员函数间接调用 private virtual 函数”，这也就是 non-virtual interface（NVI） 手法。这个 non-virtual 函数（healthValue）称为 virtual 函数的外覆器（wrapper）。</p>
<p>NVI手法涉及在 derived class 内重新定义 private virtual 函数，赋予它们“如何实现机能”的控制手段。其优点在于：外覆器能够确保一个 virtual 函数被调用之前能够设定好场景，并在调用结束之后清理场景。“事前工作”可以包括锁定互斥器（locking a mutex）、制造运转日志记录项、验证class约束条件、验证函数先决条件等。而“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证class的约束条件等。</p>
<p>注意的是，NVI手法下 virtual 函数也没必要一定为 private，有时候需要是 protected 甚至 public。</p>
</li>
<li><p><strong>通过 Function Pointers 实现 Strategy模式</strong>：</p>
<p>另一种设计主张“人物健康指数的计算与人物类型无关”，这样的计算不需要“人物”这个成分。例如，我们可以要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>         <span class="comment">// 前置声明</span></span><br><span class="line"><span class="comment">// 计算健康指数的缺省算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span> <span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:<span class="title">healthFunc</span><span class="params">(hcf)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是 Strategy 设计模式的一个简单应用，与“基于GameCharacter继承体系内的virtual函数”相比，它提供了一些有趣的弹性：</p>
<ol>
<li><p>同一人物类型的不同实体可以有不同的健康计算函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:<span class="title">healthFunc</span><span class="params">(hcf)</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;         <span class="comment">// 健康指数计算1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;          <span class="comment">// 健康指数计算2</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;        <span class="comment">// 相同类型的人物搭配不同的健康计算方式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>某已知人物的健康指数计算函数可以在运行期间变更。例如GameCharacter可提供一个成员函数 setHealthCalculator，用来替换当前的健康指数计算函数。</p>
</li>
</ol>
</li>
<li><p><strong>以 tr1::function 成员变量替换 virtual 函数</strong>，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是Strategy的某种形式。</p>
</li>
<li><p><strong>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数</strong>。这是Strategy设计模式的传统实现手法。</p>
</li>
</ul>
<p>以上并没有彻底列出 virtual 函数的所有替换方案，它们各有优缺点，为避免陷入面向对象设计路上因常规而形成的凹洞中，这值得我们花时间加以研究。</p>
<h3 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h3><p>考虑这样的情况，class D 由 class B 以public形式派生而来，class B定义有一个public成员函数mf，其参数和返回值都不重要（为简单，标记为void），而class D也有自己版本的mf函数，实现起来大概是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果有以下行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;           <span class="comment">// 获得一个指针，指向x</span></span><br><span class="line">pB-&gt;mf();             <span class="comment">// 经pB指针调用mf，将调用B::mf</span></span><br><span class="line">D* pD = &amp;x;           </span><br><span class="line">pD-&gt;mf();             <span class="comment">// 经pD指针调用mf，将调用D::mf</span></span><br></pre></td></tr></table></figure>

<p>你会比较惊奇地发现 class D 对象通过继承体系的不同指针指向，使用mf竟然会导致不同版本的调用。造成这种两面行为的原因是：<strong><u>non-virtual 函数（如B::mf 和 D::mf）都是静态绑定（statically bound）的</u></strong>。意思就是，pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生类”的对象。</p>
<p>但是另一方面，virtual函数却是动态绑定（dynamically bound），所以如果mf是个virtual函数，不论通过pB或pD调用mf，都会导致调用D::mf，因为pB和pD真正指向的都是一个类型为D的对象。</p>
<p>public继承是is-a的关系，而且non-virtual函数的“不变性”是凌驾于“特异性”之上的。如果重新定义了base class的non-virtual函数，就与设计相矛盾。这给我们的警示就是：<strong>任何情况下都不该重新定义一个继承而来的non-virtual函数</strong>。</p>
<h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p>让我们整理一下思路，将讨论简化。</p>
<ol>
<li>只能继承两种函数：virtual 和 non-virtual函数；</li>
<li>重新定义一个继承而来的 non-virtual 函数永远是错误的。</li>
</ol>
<p>那么我们对于函数继承的讨论可以安全地限制在“继承一个带有缺省参数值的virtual函数”。</p>
<p>这种情况下，本条款成立的理由就直接而明确了，因为<strong>virtual函数是动态绑定的，而缺省参数值却是静态绑定的</strong>。这意味着如果重新定义继承而来的缺省参数值，可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用了base class为它指定的缺省参数值。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue&#125;;</span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个函数，用来绘出自己</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 赋予了不同的缺省参数值！</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 注意，这么写的话，客户以对象调用此函数，一定要指定参数值，因为静态绑定下这个函数不从其base class继承缺省参数值；但如果以指针（或引用）调用此函数，却可能不指定参数值调用，因为动态绑定下可以从base class继承缺省参数值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在考虑这些指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                      <span class="comment">// 静态类型为Shape</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;      <span class="comment">// 静态类型为Shape，动态类型为Rectangle</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;         <span class="comment">// 静态类型为Shape，动态类型为Circle</span></span><br><span class="line"></span><br><span class="line">pr-&gt;draw();                     <span class="comment">// 将调用Rectangle::draw(Shape::Red)</span></span><br></pre></td></tr></table></figure>

<p>正如预期的那样，pr指向Rectangle，但是经由pr调用draw的缺省参数并不是定义Rectangle时指定的Green，而是Shape（静态绑定的基类类型）指定的Red。</p>
<p>这样的问题不光是指针，引用也会引起。其关键在于<u><em>draw是一个virtual函数，而其中的缺省参数值在derived class中被重新定义了</em></u>。</p>
<p>那么如果遵守这条规则，并尝试解决这个问题：继承一个含有缺省参数值的virtual函数。那么又会导致“重复定义缺省参数值” 或者 代码重复：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span>;          <span class="comment">// 代码重复！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比较机智的做法是使用替代的设计（条款35列出了virtual的替代设计），例如使用NVI（non-virtual interface）手法：令 base class 内的一个 non-virtual 函数调用 private virtual 函数，后者可以被 derived class 重新定义。这里可以让 non-virtual 函数指定缺省参数，而 private virtua 函数负责真正的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        doDraw(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">// 派生类重新定义该函数，实现真正的工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>&#123;    <span class="comment">// 注意，不用指定缺省参数值了</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 non-virtual 函数绝不应该被 derived class 覆写，这个设计清楚地使得 draw 函数的 color 缺省参数值总是为 Red。</p>
<h3 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h3><p>复合（composition）是类型之间的一种关系，当某种类型的对象内含其他类型的对象时，便是这种关系。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>&#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span>&#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;            <span class="comment">// 复合成分物（composed object）</span></span><br><span class="line">    Address address;             <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber voiceNumber;     <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber faxNumber;       <span class="comment">// 同上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Person对象有一个名称、一个地址以及语音和传真两笔电话号码。复合的术语也有许多同义词，包括 layering（分层）、containment（内含）、aggregation（聚和）和 embedding（内嵌）。</p>
<p>实际上，复合存在两种意义：</p>
<ul>
<li><strong>has-a（有一个）</strong>：当复合发生在<strong>应用域</strong>内的对象之间，就会表现出 <strong>has-a</strong> 的关系。</li>
<li><strong>is-implemented-in-terms-of（根据某物实现出）</strong>：当复合发生在实现域内，则表现出 <strong>is-implemented-in-terms-of</strong> 的关系。</li>
</ul>
<blockquote>
<p>程序中处理的两个不同领域：</p>
<p>应用域：程序中的对象相当于你所塑造的世界中的某些事物，例如人、汽车、视频帧等。</p>
<p>实现域：程序中的对象纯碎是实现细节上的人工制品，比如缓冲区（buffers）、互斥器（mutexes）等。</p>
</blockquote>
<p>区分 is-a 和 has-a 比较简单，而区分 is-a 和 is-implemented-in-terms-of 有时则比较困难。例如，要想自己实现一个set数据类型，并复用 linked list 作为底层数据结构。你可能会萌发一个想法：让Set继承List。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>但实际上这样的想法是完全错误的！public继承描述的是 is-a 的关系，可这完全说不通，list允许重复元素，而Set中不会存放任何一个相同的元素。所以public继承并不适合塑模他们的关系。针对此问题，更好的描述是，<strong>Set是根据List实现出的</strong>，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; rep;            <span class="comment">// 用来描述Set中的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h3><p>之前已经知道了 public 继承意味这 “is-a” 的关系，而且编译器会在必要时刻（为了让函数调用成功）会将派生类暗自转换为基类。但如果是private继承，就不会这样了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">private</span> Person&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;                <span class="comment">// 任何人都会吃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;             <span class="comment">// 学生在校学习</span></span><br><span class="line"></span><br><span class="line">Person p;  Studnet s;</span><br><span class="line">eat(p);                                   <span class="comment">// 正确</span></span><br><span class="line">eat(s);                                   <span class="comment">// 错误！这似乎有点违背常识，难道学生不是人？</span></span><br></pre></td></tr></table></figure>

<p>这个例子表明，<strong>private继承不意味这 is-a 的关系</strong>，private继承所表明的规则如下：</p>
<ol>
<li>如果classes之间的继承关系是private，编译器不会自动将一个derived class对象（例如 Student）转化为一个base class对象（例如 Person）。</li>
<li>由private base class 继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或者public属性。</li>
</ol>
<p>进一步地，<strong>private继承意味着 implemented-in-terms-of（根据某物实现出）</strong>。如果让 class D 以private形式继承 class B，你的用意是为了采用class B内已经具备的特性，而不是D和B对象存在有任何观念上的关系。private继承纯粹只是一种实现技术，这就是为什么继承自一个 private base class 的每样东西在你的 class 内都是private，因为它们都只是实现枝节而已。</p>
<p>可以发现，复合（composition）和 private继承有时可以表达相同的意思，那么应该怎么样做取舍呢？答案很简单：<strong>尽可能使用复合，必要时才使用private继承</strong>。所谓必要时候，主要是当 protected成员和/或virtual函数牵扯进来的时候。例如，我们修改 Widget class，让它记录每个成员函数的调用次数。运行期间周期性地审查这份信息，我们可以复用定时器来完成这项功能，定时器Timer的主要定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;         <span class="comment">// 定时器每滴答一次，该函数就被自动调用一次</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以调整任意频率，<em>重新定义 virtual onTick 函数</em>以取出Widget的当时状态。而让 Widget 重新定义 Timer 中的virtual函数就需要继承Timer。但 public 继承显然是不合适的，它们之间并不是 “is-a” 的关系，所以这里更适合的是使用 private 继承来完成功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">private</span> Timer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 定期查看Widget状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>private继承可以实现功能，但其实也并不是一个很好的设计。我们应该尽量使用复合的设计来取代，这里当时也是可以行得通的，只需要在Widget中声明一个嵌套式的 private class，该 class 以 public 形式继承Timer并重新定义onTick，然后将这样的class复合在Widget中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span>:</span> <span class="keyword">public</span> Timer&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设计仅比 private 继承稍稍复杂一点，涉及到 public 继承和复用，并引入一个新的类（WidgetTimer）。</p>
<p>稍微整理一下，private继承主要用于“当 ‘<u>derived class’ 想访问 ‘base class’ 中的protected成分，或为了重新定义一或多个virtual函数</u>”，<u>但这两个classes之间的概念关系是 is-implemented-in-terms-of 而非 is-a</u>。但是，有一种激进情况涉及空间最优化，可能会促使你选择“private继承”而不是“public继承+复合”。</p>
<p>这种激进的情况是这样的：<em>你所处理的class不带任何数据</em>。这样的class没有non-static成员变量，没有virtual函数（因为虚函数会为每个对象带来一个vptr），也没有virtual base class。于是这种 empty class 对象不适用任何空间，然而C++规定凡是独立（非附属）对象都必须有非零大小，所以如果你这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span>&#125;;         <span class="comment">// 没有数据，该类对象应该不使用任何内存</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span>&#123;</span>      <span class="comment">// 应该只需要一个int的空间</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而我们测试它们的大小，却能发现 sizeof(HoldsAnInt) &gt; sizeof(int)。在大多数编译器中 sizeof(Empty)会获得1，因为<strong>面临大小为0的独立(非附属)对象时，C++通常会默默安插一个char到空对象内</strong>。然而由于<strong>齐位</strong>的需求，可能会造成编译器为 HoldsAnInt 加上一些衬垫（padding）。实际中得到的各对象大小如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Empty): 1</span><br><span class="line">sizeof(HoldsAnInt): 8</span><br><span class="line">sizeof(int): 4</span><br></pre></td></tr></table></figure>

<p>那么，如果 HoldsAnInt 附属在空白类上呢？继承Empty，而不是内含一个这样类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span>:</span> <span class="keyword">private</span> Empty&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------</span><br><span class="line"><span class="keyword">sizeof</span>(Empty): <span class="number">1</span></span><br><span class="line"><span class="keyword">sizeof</span>(HoldsAnInt): <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以发现，sizeof(HoldsAnInt) == sizeof(int)。这就是所谓的 EBO（empty base optimization; 空白基类最优化），如果客户非常在意空间，那么就值得注意EBO。另外，EBO一般只有在单一继承（而非多重继承）下才可行。</p>
<p>现实中，“empty class”并不是真正的empty，不然就失去了存在的意义。虽然它们没有non-static成员，但往往内含typedefs, enums, static成员变量，或non-virtual函数。EBO的广泛实践，使得这样的继承很少增加derived class 的大小。</p>
<h3 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h3><p>多重继承（Multiple Inheritance; MI）比单一继承（Single Inheritance; SI）复杂，也会导致较多的歧义。例如：</p>
<ul>
<li><p>从一个以上的 base classes 继承相同的名称（如函数、typedef等）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorrowableItem</span>&#123;</span>         <span class="comment">// 图书馆允许你借某些东西</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;          <span class="comment">// 离开时进行检查</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectronicGadget</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 执行自我检测，返回是否测试成功</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3Player</span>:</span> <span class="keyword">public</span> BorrowableItem, <span class="keyword">public</span> ElectronicGadget&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.checkOut();         <span class="comment">// 导致歧义！到底调用的是哪个checkOut呢？</span></span><br></pre></td></tr></table></figure>

<p>当然这里ElectornicGadget中的checkOut是private，无法调用。要明确调用哪个base clas的checkOut函数也可以明确地指出类名进行调用。</p>
</li>
<li><p>菱形继承问题：继承一个以上的 base classes，但这些 base classes 在继承体系中又有更高级的 base classes。</p>
<p><img src= "/img/loading.gif" data-src="https://pic.imgdb.cn/item/63da05c9ac6ef86016cbef71.webp" alt="multiple-inheritance"></p>
<p>这样的继承方式必须面临一个问题：是否打算让 base class 内的成员变量经由每一条路径都被复制？即，数据冗余。</p>
<p>C++对于这个问题支持两种方案：</p>
<ol>
<li><p>执行复制（缺省做法）：IOFile将从每个基类继承一份，所以其对象内会有两份fileName成员变量。</p>
</li>
<li><p>不复制（采用“virtual 继承”）：令直接继承File（含公共数据的那个类）的类采用 virtual 继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span>&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span>&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span>:</span> <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>但是也得为virtual 继承付出代价。使用virtual继承的类（如InputFile）所产生的对象比 non-virtual 的更大，而且访问 virtual base class 的成员变量时的速度也会慢下来。</p>
</li>
</ol>
<blockquote>
<p>virtual继承的原理：</p>
<p>。。。</p>
</blockquote>
</li>
</ul>
<p>virtual继承会增加大小、速度、初始化（及赋值）和复杂度等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。多重继承有时也有正当用途，例如涉及到“public 继承某个 Interface class”和“private 继承某个协助实现的class”两相结合的时候。</p>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://aliez22.github.io/posts/41157/">https://aliez22.github.io/posts/41157/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://aliez22.github.io" target="_blank">zzm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/043.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/31760/"><img class="prev-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/040.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【bug】局部数组变量过大导致栈溢出</div></div></a></div><div class="next-post pull-right"><a href="/posts/23548/"><img class="next-cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/032.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【开源项目】为openEuler5.10内核增添页表检查功能</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/56896/" title="C++ primer(第五版) 要点记录"><img class="relatedPosts_cover" data-src="https://fastly.jsdelivr.net/gh/AlieZ22/CDN-for-blog/pixiv/033.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-20</div><div class="relatedPosts_title">C++ primer(第五版) 要点记录</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> zzm</div><div class="framework-info"><span> &gt;明确目标 不留余力&lt; </span></div></div><head><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script></body></html>